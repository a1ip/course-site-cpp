Кольцевой буфер
######################################################################################

:date: 2016-11-06 00:00
:status: draft

.. default-role:: code
.. contents:: Содержание

Описание
========
Кольцевой буфер, или циклический буфер (англ. ring-buffer) — это структура данных, использующая единственный буфер фиксированного размера, как будто бы после последнего элемента сразу же снова идет первый. Такая структура легко предоставляет возможность буферизации потоков данных.
Кольцевые буферы часто используют для организации различных очередей сообщений и буферов приёма-передачи различных коммуникационных интерфейсов. Популярность КБ обусловлена тем, что это один из самых простых и эффективных способов организовать FIFO (англ. first in — first out, «первым пришёл — первым вышел») без использования динамического перераспределения памяти - массив заданного размера выделяется при инициализации КБ. 

Рассмотрим реализацию кольцевого буфера, хранящего целочисленные значения с использованием массива:

.. code-block:: cpp

	#include <iostream>

	class CircularBuffer 
	{
	public:

	    CircularBuffer( int size ) 
	    {
	        head = tail = length = 0;
	        bufferSize = size;
	        arr = new int[bufferSize];
	    }

	    ~CircularBuffer()
	    {
	        delete[] arr;
	    }

	    // Добавить элемент
	    void put( const int & value ) 
	    {
	        if ( tail == bufferSize ) 
	        {
	            tail = 0;
	        }
	    
	        arr[tail] = value;
	        ++tail;
	        ++length;
	    }


	    // Извлечь последний элемент
	    int & pop()
	    { 
	        if ( head == bufferSize ) {
	            head = 0;
	        }
	        int & elem = arr[head];
	        ++head;
	        --length;
	        return elem;
	    }

	    // Кол-во элементов в буфере
	    size_t size() const 
	    {
	        return length;
	    }

	    // Ёмкость буфера
	    size_t capacity() const 
	    {
	        return bufferSize;
	    }


	private:
	    int * arr;             // массив-буфер
	    int bufferSize;        // размер буфера
	    int length;            // кол-во элементов в буффере
	    int head;              // индекс первого элемента
	    int tail;              // индекс последнего элемента
	};


	int main()
	{
	    CircularBuffer buf(3);
	 
	    for( int i = 0; i < 10; ++i )
	    {
	        buf.put( i * 2 );
	        if ( buf.size() == buf.capacity() ) {
	            std::cout << "---------------" << std::endl;
	            while( buf.size() ) {
	                std::cout << buf.pop() << std::endl;
	            }
	        }

	    }
	 
	    std::cout << "---------------" << std::endl;
	    while( buf.size() ) {
	        std::cout << buf.pop() << std::endl;
	    }
	    return 0;
	}

После компиляции и запуска программа выводит следующее (как только буфер полностью заполняется, его содержимое выводится на экран):

.. code-block:: text

	---------------
	0
	2
	4
	---------------
	6
	8
	10
	---------------
	12
	14
	16
	---------------
	18


Упражнение №1
-------------

Реализуйте оператор доступа к произвольному элементу operator[] в предположении, что значение индекса будет лежать в интервале (0,size()-1) и метод printBuffer(), печатающий в одну строчку значения переменных head, tail и содержимое буфера. Добавьте вызов этого метода после каждого изменения буфера в main.


Упражнение №2
-------------

В приведенной реализации буфер хранит целочисленные значения. Трансформируйте его в шаблон, чтобы для хранения целочисленных значений нужно было обьявить  CircularBuffer<int> buf(3);.  


Упражнение №3
-------------

В приведенной реализации данные хранятся в массиве. Измените механизм хранения на std::vector. Избавьтесь от переменных bufferSize и length.


Упражнение №4
-------------

Уберите параметр конструктора задающий емкость буфера, и сделайте его параметром шаблона. Чтобы в итоге переменная buf обьявлялась CircularBuffer<int,3> buf;.
