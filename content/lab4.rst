Си-структуры и указатели в С++. Стек и очередь. Динамический двухсвязный список на С++. 
#######################################################################################

:date: 2016-09-22 11:00

.. default-role:: code
.. contents:: Содержание

Указатели в С++
===============

Указатель – переменная, значением которой является адрес ячейки памяти. То есть указатель ссылается на начало блока данных в области памяти. Также указатель может ссылаться на переменную или функцию. Адрес переменной можно получить при помощи унарной операции взятия адреса &. 
Объявление указателя:

/*тип данных*/  * /*имя указателя*/;

Принцип объявления указателей такой же, как и принцип объявления переменных. Отличие заключается только в том, что перед именем ставится символ звёздочки \*. Визуально указатели отличаются от переменных только одним символом. При объявлении указателей компилятор выделяет несколько байт памяти, в зависимости от типа данных отводимых для хранения некоторой информации в памяти. Чтобы получить значение, записанное в некоторой области, на которое ссылается указатель нужно воспользоваться операцией разыменования указателя \*. Необходимо поставить звёздочку перед именем и получим доступ к значению указателя.

Пример:

.. code-block:: c

	#include <iostream>
	using namespace std;

	int main()
	{
		int x;
		int * y = &x;
		x = 777; 
		cout << "&x = " << &x << endl; // адрес переменной x содержащийся в памяти, извлечённый операцией взятия адреса
		cout << "y = " << y << endl;     // адрес переменной x является значением указателя y
		cout << "x = " << x << endl;  // значение в переменной x
		cout << "*y = " << *y << endl; // вывод значения содержащегося в переменной y через указатель, операцией разыменывания указателя
		return 0;
	}


Указатели используются для передачи данных, что намного ускоряет процесс обработки этих данных в случае, если объём данных большой, так как их не надо копировать, как при передаче по значению, то есть, используя имя переменной. В основном указатели используются для организации динамического распределения памяти, например при объявлении массива, не надо будет его ограничивать в размере. Ведь заранее не всегда известно, какого размера нужен массив. При разработке программ принято добавлять к имени указателя приставку p или суффикс _ptr, чтобы получить осмысленное имя указателя, и путать его с обычной переменной.

Наример:

.. code-block:: c

	int value;
	int * pValue = &value;
	int * value_ptr = &value;


Указатели можно сравнивать не только на равенство или неравенство, но и на больше-меньше ведь адреса могут быть меньше или больше относительно друг друга. 

Рассмотрим пример:

.. code-block:: c

	#include <iostream>
	using namespace std;
	 
	int main(int argc, char* argv[])
	{
		int x1 = 512; // инициализация переменной x1 числом 12
		int x2 = 434; // инициализация переменной x2 числом 34
		int *x1_ptr = &x1; // указатель на переменную x1
		int *x2_ptr = &x2; // указатель на переменную x2
		cout << "x1    = " << x1 << endl;
		cout << "x2    = " << x2 << endl;
		cout << "x1_ptr = " << x1_ptr << endl;
		cout << "x1_ptr = " << x2_ptr << endl;

		if (x1_ptr > x2_ptr) // сравниваем значения указателей (адреса переменных)
			cout << "x1_ptr > x2_ptr" << endl;
		else if (x1_ptr < x2_ptr)
			cout << "x1_ptr < x2_ptr" << endl;

		if (*x1_ptr > *x2_ptr) // сравниваем значения переменных, на которые ссылаются указатели
			cout << "*x1_ptr > *x2_ptr" << endl;
		else if (*x1_ptr < *x2_ptr)
			cout << "*x1_ptr < *x2_ptr" << endl;

		return 0;
	}


В первом случае, мы сравнивали адреса  переменных. При каждом запуске программы адреса выделяются разные. Во втором случае мы сравнивали значения этих переменных используя операцию разыменования указателя.

Из арифметических операций, чаще всего используются операции сложения, вычитания, инкремент и декремент, так как с помощью этих операций, например в массивах, вычисляется адрес следующего элемента.


Указатели на указатели
----------------------

Указатели могут ссылаться на другие указатели. При этом в ячейках памяти, на которые будут ссылаться первые указатели, будут содержаться не значения, а адреса вторых указателей. Число символов * при объявлении указателя показывает порядок указателя. Чтобы получить доступ к значению, на которое ссылается указатель его необходимо разыменовывать соответствующее количество раз. Разработаем программу, которая будет выполнять некоторые операции с указателями порядка выше первого:

.. code-block:: c

	#include <iostream>
	using namespace std;
 
	int main() {
		int x = 12; // инициализация переменной x числом 12
		int *x_ptr = &x; // указатель на переменную x
		int **x_ptr_ptr = &x_ptr; // указатель на указатель на переменную x
		int ***x_ptr_ptr_ptr = &x_ptr_ptr;
		cout << " x\t\t= " << x << endl;
		cout << " *x_ptr\t= " << *x_ptr << endl;
		cout << " **x_ptr_ptr   = " << **x_ptr_ptr << endl; // два раза разименовываем указатель, так как он второго порядка
		cout << " ***x_ptr_ptr_ptr  = " << ***x_ptr_ptr_ptr << endl; // указатель третьего порядка
		return 0;
	}


Данная программа демонстрирует тот факт, что для получения значения количество разыменований указателя должно совпадать с его порядком. Логика n-кратного разыменования заключается в том, что программа последовательно перебирает адреса всех указателей вплоть до переменной, в которой содержится значение. В программе показана реализация указателя третьего порядка. И если, используя такой  указатель (третьего порядка) необходимо получить значение, на которое он ссылается, делается 4 шага:

#. по значению указателя третьего порядка получить адрес указателя второго порядка;
#. по значению указателя второго порядка получить адрес указателя первого порядка;
#. по значению указателя первого порядка получить адрес переменной;
#. по адресу переменной получить доступ к её значению.

Указатели на функции
--------------------

Указатели могут ссылаться на функции. Имя функции, как и имя массива само по себе является указателем, то есть содержит адрес входа.

Объявление указателя на функцию

/*тип данных*/ (* /*имя указателя*/)(/*список аргументов функции*/);

Тип данных определяем такой, который будет возвращать функция, на которую будет ссылаться указатель. Символ указателя и его имя берутся в круглые скобочки, чтобы показать, что это указатель, а не функция, возвращающая указатель на определённый тип данных.  После имени указателя идут круглые скобки, в этих скобках перечисляются все аргументы через запятую как в объявлении прототипа функции. Аргументы наследуются от той функции, на которую будет ссылаться указатель. Разработаем программу, которая использует указатель на функцию. 

Рассмотрим в качестве примера программу, вычисляющую факториал:


.. code-block:: c

	#include <iostream>
	using namespace std;

	int factorial(int); // прототип указываемой функции
	
	int main()
	{
		int (*f_ptr)(int); // объявление указателя на функцию
		f_ptr=factorial; // присваиваем адрес функции указателю ptrnod
		int n;
		cout << "Enter N: ";
		cin >> n;
		cout << "N! = " << f_ptr(n) << endl; // обращаемся к функции через указатель
		return 0;
	}

	int factorial(int n) // рекурсивная функция нахождения наибольшего общего делителя НОД
	{
		return n > 1 ? n * factorial(n-1) : 1;
	}

В строке 7 объявляется указатель (f_ptr), которому в строке 8 присваивается адрес функции. Как мы уже говорили до этого, адресом функции является просто её имя. То есть данный указатель теперь указывает на функцию factorial(int). При объявлении указателя в аргументах указывается то же самое, что и в прототипе функции. 


Структуры
=========

Структуры предоставляют возможность хранения различных значений, объединенных одним общим названием. То есть одно единственное имя структуры может объединять различные переменные, они могут отличаться даже типами данных, это могут быть как массивы, строки так и обычные переменные. 

Обычно все переменные структуры связаны друг с другом. Например, информация об имени и адресе, находящаяся в списке рассылки, обычно представляется в виде структуры. Следующий фрагмент кода объявляет шаблон структуры, определяющий имя и адрес. Ключевое слово struct сообщает компилятору об объявлении структуры.

.. code-block:: c

	struct address {
		char name[32];
		char street [48]; 
		char city[32];
		char state[3];
		unsigned long int zip;
	};

Имя структуры address идентифицирует структуру данных и является спецификатором типа. Имя структуры часто используют как ярлык. Оббявление структуры создаёт никакой переменной. Определена только форма данных. Для объявления настоящей переменной, соответствующей данной структуре, следует написать:

.. code-block:: c

	struct address addr_info;

В данной строке происходит объявление переменной addr_info типа address. При объявлении структуры определяется переменная смешанного типа. До тех пор, пока не будет объявлена переменная данного типа, она не будет существовать. Когда объявлена структурная переменная, компилятор автоматически выделяет необходимый участок памяти для размещения всех ее полей. 

При объявлении структуры можно одновременно объявить одну или несколько переменных.

Например:

.. code-block:: c

	struct address {
		char name[32];
		char street[48];
		char city[32];
		char state[3];
		unsigned long int zip;
	} addr_info, binfo, cinfo;


объявляет структуру addr и объявляет переменные addr_info, binfo, cinfo данного типа.

Важно понять, что каждая вновь создаваемая структурная переменная содержит свои собственный копии переменных, образующих структуру. Например, поле zip переменной binfo отделено от поля zip переменной cinfo. Фактически, единственная связь между binfo и cinfo заключается в том, что они обе являются экземплярами одного типа структуры. Больше между ними нет связи.

Если необходима только одна структурная переменная, то нет необходимости в ярлыке структуры. Это означает, что

.. code-block:: c

	struct {
		char name[32];
		char street[48];
		char city[32];
		char state[3];
		unsigned long int zip;
	} addr_info;

объявляет одну переменную addr_info с типом, определенным предшествующей ей структурой. Стандартный вид объявления структуры следующий:

.. code-block:: c

	struct <имя типа> {
		тип имя переменной;
		тип имя переменной;
		тип имя переменной;
	} структурные переменные;

<имя типа> - это имя типа структуры, а не имя переменной. Структурные переменные - это разделенный запятыми список имен переменных. Следует помнить, что или <имя типа>, или структурные переменные могут отсутствовать, но не оба.
Доступ к отдельным полям структуры осуществляется с помощью оператора «точка». Например, следующий фрагмент кода присваивает полю zip структурной переменой addr_info значение 12345:

.. code-block:: c

	addr_info.zip = 12345;

За именем структурной переменной следует точка, а за ней имя поля, к которому происходит обращение. Ко всем полям структуры доступ осуществляется точно таким же способом. Стандартный вид доступа следующий:

.. code-block:: c

	имя_структуры.имя_поля


Следовательно, для вывода поля zip на экран надо написать:

.. code-block:: c

	printf("%ld", addr_info.zip);


Информация, содержащаяся в одной структуре, может быть присвоена другой структуре того же типа с помощью одиночного оператора присваивания, то есть не нужно присваивать значение каждого поля по отдельности. Следующая программа демонстрирует присваивание структур:

.. code-block:: c

	#include <stdio.h>
	int main(void)
	{
		struct {
			int a;
			int b;
		} x, y;
		
		x.a = 10;
		x.b = 20;
		
		у = x; /* присвоение одной структуры другой */
		
		printf ("Contents of у: %d %d.", y.a, y.b);
		
		return 0;
	}


После присваивания у.а и y.b будут содержать значения 10 и 20 соответственно.


Часто структуры используются в виде массивов структур. Для объявления массива структур следует сначала определить структуру, а затем объявить массив переменных данного типа. Например, для объявления 100-элементного массива структур типа addr следует написать:

.. code-block:: c
	
	struct addr addr_info[100];


В результате получаем набор из 100 переменных, устроенных, как объявлено в типе структуры addr. Для доступа к отдельным структурам массива adar_info следует проиндексировать имя массива. Например, для вывода содержимого поля zip третьей структуры, следует написать:

.. code-block:: c

	printf("%ld", addr_info[2].zip);

Как и массивы переменных, массивы структур индексируются с нуля.


Передача полей структур в функции
----------------------------------

При передаче полей структур в функции фактически передается значение поля. Следовательно, передается обычная переменная. Рассмотрим для примера следующую структуру:

.. code-block:: c

	struct mystruct {
		char x;
		int y;
		float z;
		char s[10];
	} var;

Ниже приведены примеры передачи каждого поля в функцию:

.. code-block:: c

	func(var.х); /* передача символьного значения х */
	func2(var.у); /* передача целочисленного значения у */
	func3(var.z); /* передача вещественного значения z */
	func4(var.s); /* передача адреса строки s */
	func(var.s[2]); /* передача символьного значения s [2] */

Тем не менее, если необходимо передать адрес отдельного поля структуры, следует поместить оператор & перед именем структуры. Например, для передачи адреса элементов структуры mike следует написать:

.. code-block:: c

	func(&var.x) ; /* передача адреса символа x */
	func2(&var.у); /* передача адреса целого у */
	func3(&var.z); /* передача адреса вещественного z */
	func4(var.s) ; /* передача адреса строки s */
	func(&var.s[2]); /* передача адреса символа s[2] */

Обратим внимание, что оператор & стоит перед именем структуры, а не перед именем поля. Помимо этого, массив s сам по себе является адресом, поэтому не требуется оператора &. Тем не менее, когда осуществляется доступ к отдельному символу строки s, как показано в последнем примере, оператор & необходим.


Битовые поля
============

В противоположность другим компьютерным языкам С имеет возможность, называемую битовыми полями, позволяющую работать с отдельными битами. Битовые поля полезны по нескольким причинам. Ниже приведены три из них:

#. Если ограничено место для хранения информации, можно сохранить несколько логических (истина/ложь) переменных в одном байте.
#. Некоторые интерфейсы устройств передают информацию, закодировав биты в один байт.
#. Некоторым процедурам кодирования необходимо получить доступ к отдельным битам в байте.

Хотя все эти функции могут выполняться с помощью битовых операторов, битовые поля могут внести большую ясность в программу.

Метод использования битовых полей для доступа к битам основан на структурах. Битовое поле, на самом деле, - это просто особый тип структуры, определяющей, какой размер имеет каждое поле. Стандартный вид объявления битовых полей следующий:

.. code-block:: c

	struct имя структуры {
		тип имя1: длина;
		тип имя2: длина;
		...
		тип имяN: длина;
	}


Битовые поля должны объявляться как int, unsigned или signed. Битовые поля длиной 1 должны объявляться как unsigned, поскольку 1 бит не может иметь знака. Битовые поля могут иметь длину от 1 до16 бит для 16-битных сред и от 1 до 32 бит для 32-битных сред.

Рассмотрим приведенное ниже определение структуры:

.. code-block:: c

	struct device {
		unsigned active : 1;
		unsigned ready : 1;
		unsigned xmt_error : 1;
	} dev_code;


Данная структура определяет три переменные по одному биту каждая. Структурная переменная dev_code может, например, использоваться для декодирования информации из порта ввода-вывода. Для такого порта следующий фрагмент кода записывает байт информации и проверяет на ошибки, используя dev_code:

.. code-block:: c
	
	void write(char с)
	{
		while(!dev_code.ready) 
			read(&dev_code); /* ждать */

		write(с); /* запись байта */
		
		while(dev_code.active) 
			read(&dev_code); /* ожидание окончания записи информации */

		if ( dev_code.xmt error ) 
			printf("Write Error");
	}

Здесь read() возвращает статус порта, write(), записывает данные.  Как можно видеть из предыдущего примера, к каждому полю происходит обращение с помощью оператора "точка". Тем не менее если обращение к структуре происходит с помощью указателя, то следует использовать оператор ->.

Нет необходимости обзывать каждое битовое поле. К полю, имеющему название, легче получить доступ. Например, если порт возвращает информацию, о том, запись невозможна в пятом бите, следует изменить структуру device следующим образом:

.. code-block:: c

	struct device {
		unsigned active : 1;
		unsigned ready : 1;
		unsigned xmt_error : 1;
		unsigned : 2;
		unsigned EOT : 1;
	} dev_code;


Битовые поля имеют некоторые ограничения. Нельзя получить адрес переменной битового поля. Переменные битового поля не могут помещаться в массив. Переходя с компьютера на компьютер нельзя быть уверенным в порядке изменения битов (слева направо или справа налево). Любой код, использующий битовые поля, зависит от компьютера.

Различные структурные переменные можно смешивать  в битовых полях. Например:

.. code-block:: c

	struct emp {
		struct addr address;
		float pay;
		unsigned lay_off:1;
		unsigned hourly:1;
		unsigned deductions:3;
	};


данная структурытура определяет запись служащего, использующую только один байт для хранения трех частей информации - статуса служащего, получил ли он зарплату и размер удержаний. Без использования битовых полей данная информация заняла бы три байта.


Объединения
===========

Объединения - это объект, позволяющий нескольким переменным различных типов занимать один участок памяти. Объявление объединения похоже на объявление структуры:

.. code-block:: c

	union union_type {
		int i; 
		char ch;
	};

Как и для структур, можно объявить переменную, поместив ее имя в конце определения или используя отдельный оператор объявления. Для объявления переменной cnvt объединения union_type следует написать:

.. code-block:: c

	union union_type cnvt;


В cnvt как целое число i, так и символ ch занимают один участок памяти. (Конечно, i занимает 2 или 4 байта, a ch — только 1). Можно обратиться к данным, сохраненным в cnvt, как к целому числу, так и к символу.

Когда объявлено объединение, компилятор автоматически создает переменную достаточного размера для хранения наибольшей переменной, присутствующей в объединении.

Для доступа к полям объединения используется синтаксис, применяемый для доступа к структурам - с помощью операторов «точка» и «стрелка». Чтобы работать с объединением напрямую, надо использовать оператор «точка». Если к переменной объединения обращение происходит с помощью указателя, надо использовать оператор «стрелка». Например, для присваивания целого числа 10 элементу i объединения cnvt следует написать:

.. code-block:: c
	
	cnvt.i = 10;

Использование объединений помогает создавать машинно-независимый (переносимый) код. Поскольку компилятор отслеживает настоящие размеры переменных, образующих объединение, уменьшается зависимость от компьютера. Не нужно беспокоиться о размере целых или вещественных чисел, символов или чего-либо еще.

Объединения часто используются при необходимости преобразования типов, поскольку можно обращаться к данным, хранящимся в объединении, совершенно различными способами. Рассмотрим проблему записи целого числа в файл. В то время как можно писать любой тип данных (включая целый) в файл с помощью fwrite(), для данной операции использование fwrite() слишком «жирно». Используя объединения, можно легко создать функцию, побайтно записывающую двоичное представление целого в файл. Хотя существует несколько способов создания данной функции, имеется один способ выполнения этого с помощью объединения. В данном примере предполагается использование 32-битных целых. Объединение состоит из одного целого и четырехбайтного массива символов:

.. code-block:: c

	union pw {
		int i;
		char ch[4];
	};

Объединение позволяет осуществить доступ к четырем байтам, образующим целое, как к отдельным символам. 


Стек и очередь
==============

Стек — тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»).

Зачастую стек реализуется в виде однонаправленного списка (каждый элемент в списке содержит помимо хранимой информации в стеке указатель на следующий элемент стека).

Но также часто стек располагается в одномерном массиве с упорядоченными адресами. Такая организация стека удобна, если элемент информации занимает в памяти фиксированное количество слов, например, 1 слово. При этом отпадает необходимость хранения в элементе стека явного указателя на следующий элемент стека, что экономит память. 

При организации стека в виде однонаправленного списка значением переменной стека является указатель на его вершину — адрес вершины. Если стек пуст, то значение указателя равно NULL.

О́чередь — абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел» (FIFO, First In — First Out). Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди), при этом выбранный элемент из очереди удаляется.


Динамический двухсвязный список
===============================
Связный спиисок — базовая динамическая структура данных в информатике, состоящая из узлов, каждый из которых содержит как собственно данные, так и одну или две ссылки («связки») на следующий и/или предыдущий узел списка. Принципиальным преимуществом перед массивом является структурная гибкость: порядок элементов связного списка может не совпадать с порядком расположения элементов данных в памяти компьютера, а порядок обхода списка всегда явно задаётся его внутренними связями.
Двусвязный список (двунаправленный связный список) - здесь ссылки в каждом узле указывают на предыдущий и на последующий узел в списке. По двусвязному списку можно эффективно передвигаться в любом направлении — как к началу, так и к концу. В этом списке проще производить удаление и перестановку элементов, так как легко доступны адреса тех элементов списка, указатели которых направлены на изменяемый элемент.


Пример реализации двухсвязного списка
-------------------------------------


.. code-block:: c

	#include <stdlib.h>
	#include <iostream.h>
	 
	struct Node       //Структура являющаяся звеном списка
	{
		int x;     //Значение x будет передаваться в список
		Node next,*prev; //Указатели на адреса следующего и предыдущего элементов списка
	};
	 

	struct List   //Создаем тип данных Список
	{
		Node *head;
		Node *tail;  //Указатели на адреса начала списка и его конца
	};
	 

	void add( List *list, int x )
	{
		Node *temp = new Node(); // Выделение памяти под новый элемент структуры
		temp->next = NULL;       // Указываем, что изначально по следующему адресу пусто
		temp->x = x;             // Записываем значение в структуру
	 
		if ( list->head != NULL ) // Если список не пуст
		{
			temp->prev = list->tail; // Указываем адрес на предыдущий элемент в соотв. поле
			list->tail->next = temp; // Указываем адрес следующего за хвостом элемента
			list->tail = temp;       //Меняем адрес хвоста
		}
		else //Если список пустой
		{
			temp->prev = NULL; // Предыдущий элемент указывает в пустоту
			list->head = list->tail = temp;    // Голова=Хвост=тот элемент, что сейчас добавили
		}
	}

	void print( List * list )
	{
		Node * temp = list->head;  // Временно указываем на адрес первого элемента
		while( temp != NULL )      // Пока не встретим пустое значение
		{
			cout << temp->x <<" "; //Выводим значение на экран
			temp = temp->next;     //Смена адреса на адрес следующего элемента
		}
		cout<<"\n";
	}
	 

Упражнение
-----------

#. Реализуйте двухсвязный список, в котором значением каждого элемента является структура, описывающай координаты точки на плоскости. 
#. Заполните список 20 случайными значениями.
#. Реализуйте функцию поиска первого и последнего элемента, равного заданному.
#. Реализуйте функцию вставки элемента в указанную позицию в списке.
#. Реализуйте функцию удаления элемента из указанной позицию в списке.
#. Реализуйте функцию, возвращающую все элементы списка, удовлетворяющие некоторому критерию, в виде отдельного списка. Критерий должен передаваться как указатель на функцию, принимающую в качестве параметра элемент списка.
#. Используя код из предыдущего задания, рачечатайте первые 5 элементов списка, которые находятся ближе всего к центру масс точек списка. Координаты центра масс вычисляются как среднее арифметическое координат всех точек.

