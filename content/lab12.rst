Шаблоны: класс размерной величины
#################################

:date: 2016-11-16 20:00

.. default-role:: code
.. contents:: Содержание

Введение
========

Ошибки, с которыми приходится сталкиваться при написании программ на языке C++, можно разделить на два класса:
ошибки времени компиляции (compile time errors) и ошибки времени исполнения (runtime errors). Первые, как это следует
из названия, могут быть обнаружены на этапе компиляции, а вторые — наоборот, только во время выполнения программы.
Пример ошибки времени компиляции:

.. code-block:: cpp

   char* ptr = nullptr;
   // несовместимые типы
   int i = 10 - ptr;					

Пример ошибки времены выполнения:

.. code-block:: cpp

    int n;
    double x, mean = 0.0;
    std::cin >> n;
    for (int i = 0; i < n; i++)
    {
    	std::cin >> x;
    	mean += x;
    }
    // при n == 0 возникнет ошибка
    mean /= n;

Очевидно, что ошибки времени компиляции очень легко отследить — для этого достаточно попытаться скомпилировать
программу. Если в тексте программы присутствуют какие-то ошибки, то компилятор обязательно об этом сообщит. Однако стоит
отметить, что большинство программных ошибок являются логическими: будучи полностью синтаксически корректной, программа
работает неверно. Сложность обнаружения таких ошибок заключается в том, что подобного рода ошибки проявляются
исключительно редко. Например, программа выше будет работать всегда, кроме случая `n == 0`. Соответственно, если не
уделять достаточно времени тестированию такой программы, логическая ошибка может быть никогда и не найдена. И цена такой
ненайденной ошибки может быть `очень высокой`__.

.. __: https://ru.wikipedia.org/wiki/Therac-25

При чём тут шаблоны?
====================

В некоторых ситуациях удаётся написать программу так, что потенциальная ошибка времени исполнения становится ошибкой
времени компиляции. В качестве примера можно рассмотреть программу, которая проводит какие-то вычисления с
использованием размерных величин. Если для этих целей использовать обычные double-ы, то можно легко сложить метры с
ньютонами:

.. code-block:: cpp	

    double distance = 100;
    double force = 10;
    // логическая ошибка в формуле,
    // которая будет приводить к некорректным результатам вычислений
    double work = distance + force;

Обнаружить такого рода ошибку в большой программе очень тяжело, поскольку она не приводит к аварийному завершению
программы: из-за неё всего лишь получаются некорректные результаты. Но можно попытаться написать специальный класс
размерной величины, который не будет позволять выполнять такие «запрещённые» действия.

Получается, что для класса должны быть определены операции сложения и вычитания, умножения и деления, но
только в том случае, когда такие действия допустимы для двух операндов с учётом их размерностей. Такой класс легко может
быть реализован при помощи шаблонов C++.

В системе СИ существует `семь`__ базовых размерностей, из которых могут быть получены все остальные.
Поэтому класс размерной величины может выглядеть вот так:

.. __: https://en.wikipedia.org/wiki/SI_base_unit#The_seven_SI_base_units

.. code-block:: cpp

   template<int L, int M, …>
   class DimQ
   {
   …
   }


Здесь шаблон имеет целочисленные параметры, которые задают размерность. Например, `ньютон = килограмм⋅метр/секунда²`.
То же самое можно записать в развёрнутом виде, перечислив все базовые размерности:

.. code-block:: text

    ньютон = метр¹⋅килограмм¹⋅секунда⁻²⋅ампер⁰⋅кельвин⁰моль⁰кандела⁰

Т.е. для обозначения размерной величины силы шаблон должен быть параметризован семью числами: 1, 1, -2, 0, 0, 0, 0.

Упражнение №1
-------------

Допишите параметры шаблонного класса `DimQ`. Добавьте поле типа double, в котором будет храниться безразмерная величина.
Добавьте конструктор, позволяющий указать значение при создании экземпляра класса.

Упражнение №2
-------------

При помощи конструкции `typedef` создайте псевдонимы типов для базовых размерностей. Например, псевдоним типа для
расстояния будет выглядеть вот так:

.. code-block:: cpp

    typedef DimQ<1, 0, 0, 0, 0, 0, 0> Length;

Создайте псевдонимы типов для скорости, ускорения, а так же безразмерной величины.


Упражнение №3
-------------

Перегрузите оператор унарного минуса для класса `DimQ`. Этот оператор должен возвращать величину той же размерности, но
противоположного знака.


Упражнение №4
-------------

Перегрузите операторы сложения и вычитания для класса `DimQ`. Учтите, что эти операции могут быть применены **только**
к величинам одинаковой размерности.


Упражнение №5
-------------

Перегрузите операторы умножения и деления для класса `DimQ`. Учтите, что эти операции могут быть применены к величинам
**любых** размерностей.


Упражнение №6
-------------

Убедитесь, что ваша реализация класса размерной величины работает корректно:

.. code-block:: cpp

   // Длина
   Length l = {100};
   // Время    
   Time t = {20};

   // Скорость
   Velocity v = l / t;

   // Ускорение
   Acceleration a = v / t;

   // Размерная величина
   auto smth = v*a*a/t;
   // Безразмерная величина
   auto dimensionless = v/v;

   // Ошибка компиляции!
   // Dimensionless d = v;
   // Mass m = v;
   // Amount a = d;


Упражнение №7
-------------

Перегрузите оператор `<<` для вывода размерной величины. Пример программы:

.. code-block:: cpp

    Length l = {100};
    Time t = {20};
    Velocity v = l / t;
    Acceleration a = v / t;

    auto smth = v*a*a/t;
    auto dimensionless = v/v;

    cout << v << endl;
    cout << a << endl;
    cout << smth << endl;
    cout << dimensionless << endl;

Пример вывода:

.. code-block:: text

   5 m/s
   0.25 m/s^2
   0.015625 m^(3)s^(-6)
   1

