Сборка проекта на С++ в GNU/Linux
#################################

:date: 2016-09-01 09:00
:status: draft

.. default-role:: code
.. contents:: Содержание

Введение
========

Язык С++ является *компилируемым*, то есть трансляция кода с языка высокого уровня на инструкции машинного кода происходит не в момент выполнения, а заранее, в процессе изготовления так называемого *исполняемого файла* (в ОС Windows такие файлы имеют расширение `.exe`, а в ОС GNU/Linux чаще всего не имеют расширения).

hello.cpp
---------

Пример простой программы на С++, которая печатает "Привет, Мир!":

.. code-block:: c

	#include <iostream>

	int main()
	{
	    std::cout << "Hello, World!" << std::endl;
	    return 0;
	}

Для вывода здесь используется стандартная библиотека `iostream`, поток вывода `cout`. 
Исполняемые операторы в программах на С++ не могут быть сами по себе — они должны быть обязательно заключены в *функции*.
`main()` — это *главная функция*, выполнение программы начинается с её вызова и заканчивается выходом из неё.
Возвращаемое значение `main()` в случае успешных вычислений должно быть равно 0, что значит "ошибка номер ноль", то есть "нет ошибки". В противном случае скрипт, вызвавший программу, может посчитать её выполнившейся с ошибкой.

Обращение ко всем объектам, функциям и константам стандартной библиотеки С++ предваряется указанием пространства имён `std::`.

Чтобы выполнить программу нужно её сохранить в текстовом файле `hello.cpp` и скомпилировать следующей командой:

.. code-block:: bash

	$ g++ -o hello hello.cpp

Опция -o сообщает компилятору, что итоговый исполняемый файл должен называться `hello`.

Упражнение №1
-------------

Скомпилируйте и выполните данную программу.

Ввод и вывод на языке С++
=========================

В Си они были синтаксически оформлены как вызов функции, а в С++ — это операция над объектом специального типа — потоком.

Потоки определяются в библиотеке iostream, где определен вывод для каждого встроенного типа.

Вывод
-----

Все идентификаторы стандартной библиотеки шаблонов STL (Standard Template Library) определены в пространстве имен std, что означает необходимость обращения к ним через квалификатор std::.

.. code-block:: c

	std::cout << "mipt";
	std::cout << 2016;
	std::cout << '.';
	std::cout << true;
	std::cout << std::endl;

Заметим, что в С++ мы не прописываем типы выводимых значений, компилятор неким (пока непонятным) способом разбирается в типе выводимого значения, и выводит его соответствующим образом.

Вывод в один и тот же поток можно писать в одну строчку:

.. code-block:: c

	std::cout << "mipt" << 2016 << '.' << true << std::endl;

Для вывода в поток ошибок определён поток `cerr`.

Ввод
----

Поток ввода с клавиатуры называется `cin`, а считывание из потока производится другой операцией — `>>` :

.. code-block:: c

	std::cin >> x;

Тип считываемого значения определяется автоматически по типу переменной `x`.

Для всех типов, кроме `char`, считывание будет производиться с пропуском символов-разделителей и до следующего символа-разделителя. При этом пробел и табуляция так же как и символ перевода каретки являются корректными разделителями. Считывание в char происходит посимвольно независимо от типа символа.

Например для введенной строки "Иван Иванович Иванов",

.. code-block:: c

	std::string name;
	std::cin >> name;

считает в name только первое слово "Иван".

Считать всю строку целиком можно с помощью функции `getline()`:

.. code-block:: c

	std::string name;
	std::getline(std::cin, name);

Считывать несколько значений можно также в одну строку:

.. code-block:: c

	std::cin >> x >> y >> z;


Этапы сборки: препроцессинг, компиляция, компоновка
===================================================

Компиляция исходных текстов на Си в исполняемый файл происходит в три этапа.

.. image:: {filename}/images/lab1/lab1_1.png

Препроцессинг
-------------

Эту операцию осуществляет текстовый препроцессор.

Исходный текст частично обрабатывается — производятся:

#. Замена комментариев пустыми строками
#. Текстовое включение файлов — #include
#. Макроподстановки — #define
#. Обработка директив условной компиляции — #if, #ifdef, #elif, #else, #endif

Компиляция
----------

Процесс компиляции состоит из следующих этапов:

#. Лексический анализ. Последовательность символов исходного файла преобразуется в последовательность лексем.
#. Синтаксический анализ. Последовательность лексем преобразуется в дерево разбора.
#. Семантический анализ. Дерево разбора обрабатывается с целью установления его семантики (смысла) — например, привязка идентификаторов к их декларациям, типам, проверка совместимости, определение типов выражений и т. д.
#. Оптимизация. Выполняется удаление излишних конструкций и упрощение кода с сохранением его смысла.
#. Генерация кода. Из промежуточного представления порождается объектный код.

Результатом компиляции является *объектный код*.

Объектный код — это программа на языке машинных кодов с частичным сохранением символьной информации, необходимой в процессе сборки.

При отладочной сборке возможно сохранение большого количества символьной информации (идентификаторов переменных, функций, а также типов).


Компоновка
----------

Также называется *связывание* или *линковка*.

Это последний этап процесса получения исполняемого файла, состоящий из связывания воедино всех объектных файлов проекта.

При этом возможны ошибки связывания.

Если, допустим, функция была объявлена, но не определена, ошибка обнаружится только на этом этапе.



Принцип раздельной компиляции
=============================


Пример подключения пользовательской библиотеки в С++
====================================================

Подключение пользовательской библиотеки в С++ на самом деле не так просто, как кажется.

Рассмотрим пример: есть желание вынести часть кода в отдельный файл — пользовательскую библиотеку.

program.c
---------

.. code-block:: c

	#include "mylib.h"
	const int MAX_DIVISORS_NUMBER = 10000;

	int main()
	{
	    int number = read_number();

	    int Divisor[MAX_DIVISORS_NUMBER];
	    size_t Divisor_top = 0;
	    factorize(number, Divisor, &Divisor_top);

	    print_array(Divisor, Divisor_top);
	    return 0;
	}

 

Сама библиотека должна состоять из двух файлов: mylib.h и mylib.c.

mylib.h
-------

.. code-block:: c

	#ifndef MY_LIBRARY_H_INCLUDED
	#define MY_LIBRARY_H_INCLUDED

	#include <cstdlib>

	//считываем число
	int read_number();

	//получаем простые делители числа
	// сохраняем их в массив, чей адрес нам передан
	void factorize(int number, int *Divisor, int *Divisor_top);

	//выводим число
	void print_number(int number);

	//распечатывает массив размера A_size в одной строке через TAB
	void print_array(int A[], size_t A_size);

	#endif // MY_LIBRARY_H_INCLUDED


mylib.c
-------

.. code-block:: c

	#include <iostream>

	#include "my_library.h"

	//считываем число
	int read_number()
	{
	    int number;
	    std::cin >> number;
	    return number;
	}

	//получаем простые делители числа
	// сохраняем их в массив, чей адрес нам передан
	void factorize(int x, int *Divisor, int *Divisor_top)
	{
	    for (int d = 2; d <= x; d++) {
	        while (x%d == 0) {
	            Divisor[(*Divisor_top)++] = d;
	            x /= d;
	        }
	    }
	}

	//выводим число
	void print_number(int number)
	{
	    std::cout << number << std::endl;
	}

	//распечатывает массив размера A_size в одной строке через TAB
	void print_array(int A[], size_t A_size)
	{
	    for(int i = A_size-1; i >= 0; i--)
	    {
	        std::cout << A[i] << '\t';
	    }
	    std::cout << std::endl;
	}
 

Препроцессор С++, встречая #include "mylib.h", полностью копирует содержимое указанного файла (как текст) в место вызова директивы. Благодаря этому на этапе компиляции не возникает ошибок типа Unknown identifier при использовании функций из библиотеки.

Файл mylib.c компилируется отдельно.

А на этапе компоновки полученный файл mylib.o должен быть включен в исполняемый файл program.exe.

Cреда разработки обычно скрывает весь этот процесс от программиста, но для корректного анализа ошибок сборки важно представлять себе как это делается.


Makefile и утилита make
=======================


Обработка потока чисел 
======================
