Сборка проекта на С++ в GNU/Linux
#################################

:date: 2016-09-01 09:00
:status: draft

.. default-role:: code
.. contents:: Содержание

Введение
========

Язык С++ является *компилируемым*, то есть трансляция кода с языка высокого уровня на инструкции машинного кода происходит не в момент выполнения, а заранее, в процессе изготовления так называемого *исполняемого файла* (в ОС Windows такие файлы имеют расширение `.exe`, а в ОС GNU/Linux чаще всего не имеют расширения).

hello.cpp
---------

Пример простой программы на С++, которая печатает "Привет, Мир!":

.. code-block:: c

	#include <iostream>

	int main()
	{
	    std::cout << "Hello, World!" << std::endl;
	    return 0;
	}

Для вывода здесь используется стандартная библиотека `iostream`, поток вывода `cout`. 

Исполняемые операторы в программах на С++ не могут быть сами по себе — они должны быть обязательно заключены в *функции*.

Функция `main()` — это *главная функция*, выполнение программы начинается с её вызова и заканчивается выходом из неё.
Возвращаемое значение `main()` в случае успешных вычислений должно быть равно 0, что значит "ошибка номер ноль", то есть "нет ошибки". В противном случае скрипт, вызвавший программу, может посчитать её выполнившейся с ошибкой.

Чтобы выполнить программу, нужно её сохранить в текстовом файле `hello.cpp` и скомпилировать следующей командой:

.. code-block:: bash

	$ g++ -o hello hello.cpp

Опция -o сообщает компилятору, что итоговый исполняемый файл должен называться `hello`.

Упражнение №1
-------------

Скомпилируйте и выполните данную программу.

Ввод и вывод на языке С++
=========================

В Python и в С ввод и вывод синтаксически оформлены как вызов функции, а в С++ — это *операция* над объектом специального типа — *потоком*.

Потоки определяются в библиотеке `iostream,` где определен вывод для каждого встроенного типа.

Вывод
-----

Все идентификаторы стандартной библиотеки определены в пространстве имен `std`, что означает необходимость обращения к ним через квалификатор `std::`.

.. code-block:: c

	std::cout << "mipt";
	std::cout << 2016;
	std::cout << '.';
	std::cout << true;
	std::cout << std::endl;

Заметим, что в С++ мы не прописываем типы выводимых значений, компилятор неким (пока непонятным) способом разбирается в типе выводимого значения, и выводит его соответствующим образом.

Вывод в один и тот же поток можно писать в одну строчку:

.. code-block:: c

	std::cout << "mipt" << 2016 << '.' << true << std::endl;

Для вывода в поток ошибок определён поток `cerr`.

Ввод
----

Поток ввода с клавиатуры называется `cin`, а считывание из потока производится другой операцией — `>>` :

.. code-block:: c

	std::cin >> x;

Тип считываемого значения определяется автоматически по типу переменной `x`.

Для всех типов, кроме `char`, считывание будет производиться с пропуском символов-разделителей и до следующего символа-разделителя. При этом пробел и табуляция так же как и символ перевода каретки являются корректными разделителями. Считывание в char происходит посимвольно независимо от типа символа.

Например для введенной строки "Иван Иванович Иванов",

.. code-block:: c

	std::string name;
	std::cin >> name;

считает в name только первое слово "Иван".

Считать всю строку целиком можно с помощью функции `getline()`:

.. code-block:: c

	std::string name;
	std::getline(std::cin, name);

Считывать несколько значений можно также в одну строку:

.. code-block:: c

	std::cin >> x >> y >> z;


Упражнение №2
-------------

Напишите программу, которая считает гипотенузу прямоугольного треугольника по двум катетам. Ввод и вывод стандартные.

+--------+---------+
| Ввод   | Вывод   |
+--------+---------+
| 3 4    | 5       |
+--------+---------+


Этапы сборки: препроцессинг, компиляция, компоновка
===================================================

Компиляция исходных текстов на Си в исполняемый файл происходит в три этапа.

.. image:: {filename}/images/lab1/lab1_1.png

Препроцессинг
-------------

Эту операцию осуществляет текстовый препроцессор.

Исходный текст частично обрабатывается — производятся:

#. Замена комментариев пустыми строками
#. Текстовое включение файлов — `#include`
#. Макроподстановки — `#define`
#. Обработка директив условной компиляции — `#if`, `#ifdef`, `#elif`, `#else`, `#endif`

Компиляция
----------

Процесс компиляции состоит из следующих этапов:

#. Лексический анализ. Последовательность символов исходного файла преобразуется в последовательность лексем.
#. Синтаксический анализ. Последовательность лексем преобразуется в дерево разбора.
#. Семантический анализ. Дерево разбора обрабатывается с целью установления его семантики (смысла) — например, привязка идентификаторов к их декларациям, типам, проверка совместимости, определение типов выражений и т. д.
#. Оптимизация. Выполняется удаление излишних конструкций и упрощение кода с сохранением его смысла.
#. Генерация кода. Из промежуточного представления порождается объектный код.

Результатом компиляции является *объектный код*.

Объектный код — это программа на языке машинных кодов с частичным сохранением символьной информации, необходимой в процессе сборки.

При отладочной сборке возможно сохранение большого количества символьной информации (идентификаторов переменных, функций, а также типов).


Компоновка
----------

Компоновка также называется *связывание* или *линковка*. На этом этапе отдельные объектные файлы проекта соединяются в единый *исполняемый файл*.

На этом этапе возможны ошибки, так называемые ошибки связывания: если функция была объявлена, но не определена, ошибка обнаружится только на этом этапе.

Упражнение №3
-------------

Выполните в консоли для ранее созданного файла hello.cpp последовательно операции препроцессинга, компиляции и компоновки:

#. Препроцессинг:
	`$ g++ -E -o hello1.cpp hello.cpp`
#. Компиляция:
	`$ g++ -c -o hello.o hello1.cpp`
#. Компоновка:
	`$ g++ -o hello hello.o`

Принцип раздельной компиляции
=============================

Компиляция — алгоритмически сложный процесс, для больших программных проектов требующий существенного времени и вычислительных возможностей ЭВМ.
Благодаря наличию в процессе сборки программы этапа компоновки (связывания) возникает возможность *раздельной компиляции*.

В модульном подходе программный код разбивается на несколько файлов `.cpp`, каждый из которых компилируется отдельно от остальных.

Это позволяет значительно уменьшить время перекомпиляции при изменениях, вносимых лишь в небольшое количество исходных файлов. Также это даёт возможность замены отдельных компонентов конечного программного продукта, без необходимости пересборки всего проекта.


Пример модульной программы с раздельной компиляцией на С++
==========================================================

Рассмотрим пример: есть желание вынести часть кода в отдельный файл — пользовательскую библиотеку.

program.cpp
-----------

.. code-block:: c

	#include "mylib.h"
	const int MAX_DIVISORS_NUMBER = 10000;

	int main()
	{
	    int number = read_number();

	    int Divisor[MAX_DIVISORS_NUMBER];
	    size_t Divisor_top = 0;
	    factorize(number, Divisor, &Divisor_top);

	    print_array(Divisor, Divisor_top);
	    return 0;
	}

 
Подключение пользовательской библиотеки в С++ на самом деле не так просто, как кажется.

Сама библиотека должна состоять из двух файлов: `mylib.h` и `mylib.cpp`:

mylib.h
-------

.. code-block:: c

	#ifndef MY_LIBRARY_H_INCLUDED
	#define MY_LIBRARY_H_INCLUDED

	#include <cstdlib>

	//считываем число
	int read_number();

	//получаем простые делители числа
	// сохраняем их в массив, чей адрес нам передан
	void factorize(int number, int *Divisor, int *Divisor_top);

	//выводим число
	void print_number(int number);

	//распечатывает массив размера A_size в одной строке через TAB
	void print_array(int A[], size_t A_size);

	#endif // MY_LIBRARY_H_INCLUDED


mylib.cpp
---------

.. code-block:: c

	#include <iostream>

	#include "my_library.h"

	//считываем число
	int read_number()
	{
	    int number;
	    std::cin >> number;
	    return number;
	}

	//получаем простые делители числа
	// сохраняем их в массив, чей адрес нам передан
	void factorize(int x, int *Divisor, int *Divisor_top)
	{
	    for (int d = 2; d <= x; d++) {
	        while (x%d == 0) {
	            Divisor[(*Divisor_top)++] = d;
	            x /= d;
	        }
	    }
	}

	//выводим число
	void print_number(int number)
	{
	    std::cout << number << std::endl;
	}

	//распечатывает массив размера A_size в одной строке через TAB
	void print_array(int A[], size_t A_size)
	{
	    for(int i = A_size-1; i >= 0; i--)
	    {
	        std::cout << A[i] << '\t';
	    }
	    std::cout << std::endl;
	}
 

Препроцессор С++, встречая `#include "mylib.h"`, полностью копирует содержимое указанного файла (как текст) в место вызова директивы. Благодаря этому на этапе компиляции не возникает ошибок типа Unknown identifier при использовании функций из библиотеки.

Файл `mylib.c` компилируется отдельно.

А на этапе компоновки полученный файл `mylib.o` должен быть включен в исполняемый файл `program.exe`.

Cреда разработки обычно скрывает весь этот процесс от программиста, но для корректного анализа ошибок сборки важно представлять себе как это делается.

Упражнение №4
-------------

Давайте сделаем это руками:

.. code-block:: bash

	$ g++ -c mylib.cpp                      # 1
	$ g++ -c program.cpp                    # 2
	$ g++ -o program.exe mylib.o program.o  # 3

Теперь, если изменения коснутся только `mylib.cpp`, то достаточно выполнить только команды 1 и 3.
Если только program.cpp, то только команды 2 и 3.
И только в случае, когда изменения коснутся интерфейса библиотеки, т.е. заголовочного файла `mylib.h`, придётся перекомпилировать оба объектных файла.

Makefile и утилита make
=======================

Для того, чтобы упросить сборку проекта существует утилита `make`, которая сама отслеживает по отметкам времени каждого из имеющихся объектных файлов (при их наличии), требуется ли их пересборка.

