Основные команды bash. Переменные окружения. bash скрипты. 
##########################################################

:date: 2017-02-09 09:00

.. default-role:: code
.. contents:: Содержание

Что такое bash
==============

Bash (акроним от "Bourne-again SHell") это стандартный интерпретатор команд на большинстве линукс систем. В его обязанности входит обработка и исполнение команд с помощью которых пользователь управляет компьютером. После того как вы завершили работу, можно завершить процесс командного интерпретатора. После нажатия клавиш Ctrl–D, команд exit или logout процесс командного интерпретатора будет завершен и на экране снова появится приглашение ввести имя пользователя и пароль.

Для выполения команд на удаленном сервере и передачи файлов используется протокол SSH, который позволяет передавать через безопасный канал любой другой сетевой протокол, таким образом, можно не только удаленно работать на компьютере, но и передавать по шифрованному каналу звуковой поток или видео (например, с веб-камеры). Также, SSH может использовать сжатие передаваемых данных
для последующей их шифрации.  Большинство хостинг-провайдеров за определенную плату предоставляют клиентам доступ к их домашнему каталогу по SSH. Это очень удобно как для работы в командной строке, так и для удаленного запуска графических приложений. Через SSH можно работать и в локальной сети. Если вам лень ходить к серверам - администрируйте их удаленно, используя любой SSH-клиент.


Чтобы подключиться к удаленному серверу из Linux или FreeBSD используйте команды ssh:

.. code-block:: c

	$ ssh user@server_host_name


Под Windows можно воспользоваться программой PuTTY. Она имеет простой графический интерфейс, через который удобно настраивать подключения. 
После удачной авторизации у пользователя появляется возможность запускать команды на удаленном сервере в стандартном интерпретаторе.

Рассмотрим различные команды, которые можно исполнять в bash'e:
Использование "cd"

Начнем использовать bash для навигации по файловой системе. Для начала напечатайте следующую команду:

.. code-block:: c

	$ cd /


Этой командой мы указали bash-у что хотим переместиться в корневую директорию — /. Все директории в системе организованы в древовидную структуру и / это её начало (или корень). Команда cd служит для изменения текущей рабочей директории.

Чтобы узнать в каком месте файловой системы в данный момент вы находитесь (текущую рабочую директорию) наберите:

.. code-block:: c

	$ pwd


В приведенном выше примере / — аргумент команды cd — называется путь. Это место файловой системы, куда мы хотим переместиться. В данном случае / — абсолютный путь, это значит что путь указан относительно корневой директории.

Абсолютные пути
---------------

Вот несколько примеров абсолютных путей:

.. code-block:: c

	/dev
	/usr
	/usr/bin
	/usr/local/bin


Все эти пути объединяет то, что они начинаются с /. Указывая путь /usr/local/bin в качестве аргумента команде cd мы говорим ей перейти в корневую директорию /, затем в директорию usr, потом в local и bin. Абсолютные пути всегда начинаются с /.

Относительные пути
------------------

Второй вид путей называется относительными. Bash, команда cd и другие команды отсчитывают эти пути относительно текущей директории. Относительные пути никогда не начинаются с /. Например, если мы находимся в /usr

.. code-block:: c

	cd /usr


Затем мы можем перейти в /usr/local/bin используя относительный путь

.. code-block:: c

	$ cd local/bin
	$ pwd
	/usr/local/bin


Использование ".."
------------------

Относительные пути могут содержать одну или несколько директорий "..". Директория ".." указывает на родительскую директорию по отношению к нашей рабочей директории. Пример:

.. code-block:: c

	$ pwd
	/usr/local/bin
	$ cd ..
	$ pwd
	/usr/local


Команда cd .. 'поднимает на уровень выше'. Можно добавить ".."" к относительному пути. Это позволит переместиться в директорию, которая находится на одном уровне с той которая является рабочей. Пример:

.. code-block:: c

	$ pwd
	/usr/local
	$ cd ../share
	$ pwd
	/usr/share

Примеры с использованием относительных путей
--------------------------------------------

Относительные пути могут быть довольно сложными. Вот несколько примеров. Результат выполнения команд не показан, попробуйте определить в какой директории вы окажетесь используя bash.

.. code-block:: c

	$ cd /bin
	$ cd ../usr/share/zoneinfo

	$ cd /usr/lib/debug/lib
	$ cd ../usr/lib

	$ cd /usr/bin
	$ cd ../bin/../bin


Рабочая директория "."
----------------------

Перед тем как завершить рассмотрение команды cd, следует упомянуть, что, существует ещё одна специальная директория ".", которая указывает на текущую директорию. Эта директория используется для запуска исполняемых файлов, находящихся в текущей директории.

.. code-block:: c

	$ ./myprog


В последнем примере myprog это исполняемый файл находящийся в текущей директории, который будет запущен на исполнение.


cd и домашняя директория пользователя
-------------------------------------

Для того чтобы перейти в домашнюю директорию, нужно набрать

.. code-block:: c

	$ cd


Без аргумента cd сделает домашнюю директорию текущей. Для суперпользователя домашней обычно является директория /root, а для обычных пользователей — /home/username/. Если нужно указать конкретный файл, находящийся в домашней директории, то можно написать:

.. code-block:: c

	$ ./myprog /home/user/myfile.txt


Использовать абсолютные пути к файлам не всегда удобно. Эту же операцию можно сделать при помощи ~–тильды:

.. code-block:: c

	$ ./myprog ~/myfile.txt


~ — специальное имя, указывающее в bash на домашнюю директорию пользователя.

Домашние директории других пользователей
----------------------------------------

Чтобы указать файл в домашней директории другого пользователя нужно после тильды указать имя этого пользователя. Например, чтобы указать на файл fredsfile.txt находящийся в домашней директории пользователя fred:

.. code-block:: c

	$ ./myprog ~fred/fredsfile.txt


ls
--

Команда ls вызванная без аргументов, выводит на экран список файлов хранящихся в рабочей директории:

.. code-block:: c

	$ cd /usr
	$ ls
	X11R6      doc         i686-pc-linux-gnu  lib      man          sbin   ssl
	bin        gentoo-x86  include            libexec  portage      share  tmp
	distfiles  i686-linux  info               local    portage.old  src


Если указать опцию -a, можно будет увидеть все файлы, включая скрытые (имена которых начинаются с точки).

.. code-block:: c

	$ ls -a
	.      bin        gentoo-x86         include  libexec  portage      share  tmp
	..     distfiles  i686-linux         info     local    portage.old  src
	X11R6  doc        i686-pc-linux-gnu  lib      man      sbin         ssl


После самой команды ls в качестве ее аргумента можно указать один или более файлов или директорий. Если указать имя файла, то команда ls выведет информацию только об этом файле. А если указать название директории, ls покажет все ее содержимое. Опция '-l' команды ls бывает очень полезной если нужно кроме имен файлов узнать более подробную информацию о них (права на файл, имя владельца, время последнего изменения файла и его размер). Добавление опции -t сортирует файлы по дате последнего изменения, а -r - сортирует выводимый результат в обратном порядке.  
В следующем примере показано применение опции '-l' для вывода информации о файлах хранящихся в директории /usr:

.. code-block:: c

	$ ls -l /usr
	drwxr-xr-x    7 root     root          168 Nov 24 14:02 X11R6
	drwxr-xr-x    2 root     root        14576 Dec 27 08:56 bin
	drwxr-xr-x    2 root     root         8856 Dec 26 12:47 distfiles
	lrwxrwxrwx    1 root     root            9 Dec 22 20:57 doc -> share/doc
	drwxr-xr-x   62 root     root         1856 Dec 27 15:54 gentoo-x86
	drwxr-xr-x    4 root     root          152 Dec 12 23:10 i686-linux
	drwxr-xr-x    4 root     root           96 Nov 24 13:17 i686-pc-linux-gnu
	drwxr-xr-x   54 root     root         5992 Dec 24 22:30 include
	lrwxrwxrwx    1 root     root           10 Dec 22 20:57 info -> share/info
	drwxr-xr-x   28 root     root        13552 Dec 26 00:31 lib
	drwxr-xr-x    3 root     root           72 Nov 25 00:34 libexec
	drwxr-xr-x    8 root     root          240 Dec 22 20:57 local
	lrwxrwxrwx    1 root     root            9 Dec 22 20:57 man -> share/man
	lrwxrwxrwx    1 root     root           11 Dec  8 07:59 portage -> gentoo-x86/
	drwxr-xr-x   60 root     root         1864 Dec  8 07:55 portage.old
	drwxr-xr-x    3 root     root         3096 Dec 22 20:57 sbin
	drwxr-xr-x   46 root     root         1144 Dec 24 15:32 share
	drwxr-xr-x    8 root     root          328 Dec 26 00:07 src
	drwxr-xr-x    6 root     root          176 Nov 24 14:25 ssl
	lrwxrwxrwx    1 root     root           10 Dec 22 20:57 tmp -> ../var/tmp


В первой колонке показана информация о правах доступа к каждому файлу в списке. Следующая колонка показывает количество ссылок на каждый элемент списка. Третья и четвертая колонки — владелец и группа файла соответственно. Пятая колонка — размер. Шестая — время последнего изменения файла ('last modified time' или mtime). Последняя колонка — имя файла или директории (Если это ссылка, то после знака '–>' стоит имя объекта на который она ссылается).

Иногда возникает потребность посмотреть информацию только о директориях, а не о всем их содержимом. Для этого нужно воспользоваться опцией '-d', которая указывает команде выводить информацию только о директориях. Пример:

.. code-block:: c

	$ ls -dl /usr /usr/bin /usr/X11R6/bin ../share
	drwxr-xr-x    4 root     root           96 Dec 18 18:17 ../share
	drwxr-xr-x   17 root     root          576 Dec 24 09:03 /usr
	drwxr-xr-x    2 root     root         3192 Dec 26 12:52 /usr/X11R6/bin
	drwxr-xr-x    2 root     root        14576 Dec 27 08:56 /usr/bin


Действие опции '-R' противоположно действию '-d'. Она позволяет выводить информацию о файлах находящихся в директории рекурсивно. Сначала показывается содержимое директории верхнего уровня, потом по очереди содержимое всех поддиректорий и так далее. Вывод этой команды может быть достаточно объемным, поэтому  пример приводится не будет, но можно попробовать сделать это самостоятельно, набрав в командной строке 'ls -R' или 'ls -Rl'.

И, наконец, опция '-i' используется для вывода inode каждого объекта файловой системы.

.. code-block:: c

	$ ls -i /usr
	1409 X11R6        314258 i686-linux           43090 libexec        13394 sbin	
	1417 bin            1513 i686-pc-linux-gnu     5120 local          13408 share
	8316 distfiles      1517 include                776 man            23779 src
	43 doc            1386 info                 93892 portage        36737 ssl
	70744 gentoo-x86     1585 lib                   5132 portage.old      784 tmp


Каждый объект файловой системы (файл, директория...) имеет свой уникальный номер, называемый инодом (inode number). Эта информация может показаться незначительной, но понимание функции inode возволяет разобраться во многих операциях над файловой системой. Например, посмотрим на "." и ".." как на ссылки, присутствующие в каждой директории. Чтобы понять что из себя представляет директория "..", узнаем inode директории /use/local:

.. code-block:: c

	$ ls -id /usr/local
	5120 /usr/local


В данном примере, inode директории /usr/local — 5120. Теперь посмотрим какой inode у директории /usr/local/bin/..:

.. code-block:: c

	$ ls -id /usr/local/bin/..
	5120 /usr/local/bin/..


Получается, что inode директорий /usr/local и /usr/local/bin/.. совпадают. Это значит, что на inode 5120 ссылаются два имени: /usr/local и /usr/local/bin/.. То есть это два разных имени одной директории. Каждый inode указывает на определенное место на диске.
С каждым inode может быть связано несколько имен объектов файловой системы. Количество 'синонимов' файла (объектов файловой системы, ссылающихся на один inode) показывает число во втором столбце вывода команды 'ls -l':

.. code-block:: c

	$ ls -dl /usr/local
	drwxr-xr-x    8 root     root          240 Dec 22 20:57 /usr/local


На этом примере видно (второй столбец), что на директорию /usr/local ссылаются 8 разных объектов файловой системы. Вот их имена:

.. code-block:: c

	/usr/local
	/usr/local/.
	/usr/local/bin/..
	/usr/local/games/..
	/usr/local/lib/..
	/usr/local/sbin/..
	/usr/local/share/..
	/usr/local/src/..


mkdir
-----

Рассмотрим команду mkdir. Она служит для создания новых директорий. В следующем примере демонстрируется создание трех новых директорий (tic, tac, toe) в директории /tmp:

.. code-block:: c

	$ cd /tmp
	$ mkdir tic tac toe


По умолчанию команда mkdir не может создать вложенной структуры директорий. Поэтому, если вам нужно создать несколько вложенных одна в другую директорий (won/der/ful), то придется три раза поочередно вызывать эту команду:

.. code-block:: c

	$ mkdir won/der/ful
	mkdir: cannot create directory 'won/der/ful': No such file or directory
	$ mkdir won
	$ mkdir won/der
	$ mkdir won/der/ful


Упростить эту операцию можно добавив опцию '-p' к команде mkdir. Эта опция позволяет создавать вложенную структуру директорий:

.. code-block:: c

	$ mkdir -p easy/as/pie


Чтобы узнать о возможностях этой утилиты подробнее, прочитайте справку, которая вызывается командой man mkdir. Справки есть практически ко всем командам, рассмотренным в данной работе (например man ls), кроме cd, т.к. она встроена в bash (для таких команд справка вызывается так: help cd)

touch, echo, cp, mv
-------------------

Перейдем к изучению команд cp и mv, служащих для копирования, переименования и перемещения файлов и директорий. Но перед этим создадим пустой файл в директории /tmp при помощи команды touch:

.. code-block:: c

	$ cd /tmp
	$ touch copyme

Команда touch обновляет время последнего доступа к файлу (шестая колонка вывода команды ls -l) если он уже существует или создает новый пустой файл, если его ещё нету. После этой операции должен появиться пустой файл /tmp/copyme.

Теперь, когда у нас есть пустой файл, запишем в него текстовую строку при помощи команды echo, которая выводит переданный ей аргумент на стандартное устройство вывода (текстовый терминал в нашем случае).

.. code-block:: c

	$ echo "firstfile"
	firstfile


Чтобы записать строку в наш файл, нужно перенаправить в него вывод команды echo:

.. code-block:: c

	$ echo "firstfile" > copyme


Знак > (больше) указывает командной оболочке что нужно перенаправить вывод команды стоящей слева в файл, имя которого находится справа. Если файла с таким именем не существует, он будет создан автоматически. А если такой файл уже есть, то он будет перезаписан (все его содержимое будет стерто перед записью нашей строки). Команда 'ls -l' покажет что размер созданного файла теперь равен 10 байтам — девять байт занимает слово 'firstfile' и один байт символ перевода строки.

.. code-block:: c

	$ ls -l copyme
	-rw-r--r--    1 root     root           10 Dec 28 14:13 copyme


Для вывода содержимого файла на терминал используется команда cat:

.. code-block:: c

	$ cat copyme
	firstfile

Для постраничного просмотра содержимого файла можно использовать команды less или more. Если нужно вывести первые или последние строки файла, то воспользуйтесь командами head/tail. Команда head выводит первые десять строк файла, a tail - последние десять. Количество строк задается с помощью параметра -n.

Теперь рассмотрим базовую функциональность команды cp. Эта команда принимает два аргумента. Первый — имя уже существующего файла ('copyme'), второй — название новой копии, которую необходимо сделать ('copiedme').

.. code-block:: c

	$ cp copyme copiedme


Новая копия файла имеет другой номер inode (это значит что мы был создан действительно новый отдельный файл, а не просто ссылка на старый)

.. code-block:: c

	$ ls -i copyme copiedme
	648284 copiedme   650704 copyme


Теперь применим команду mv чтобы переименовать файл ("copiedme" –> "movedme"). Номер inode после этой операции не меняется, а изменяется только название файла.

.. code-block:: c

	$ mv copiedme movedme
	$ ls -i movedme
	648284 movedme


Номер inode не изменяется только при условии, что переименованный файл остается в пределах той файловой системы где находился исходный файл.  Команда mv позволяет не только переименовывать файлы, но и перемещать их. Например, чтобы переместить файл /var/tmp/myfile.txt в директорию /home/user нужно дать команду:

.. code-block:: c

	$ mv /var/tmp/myfile.txt /home/user


Файл будет перемещен в домашнюю директорию пользователя user даже если она находится в другой файловой системе (в этом случае файл будет скопирован в новое место после чего оригинал будет удален). Перемещение файла в другую файловую систему приводит к изменению его inode. Это происходит потому, что каждая файловая система имеет свой отдельный набор inode. Нужно заметить, существует вероятность, что новый присвоенный номер inode может совпасть со старым, но она чрезвычайно мала.

Чтобы переместить одновременно несколько файлов в одну директорию нужно написать:

.. code-block:: c

	$ mv /var/tmp/myfile1.txt /var/tmp/myfile2.txt /home/user

или

.. code-block:: c

	$ mv -t /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt


Если добавить опцию '-v', на экран будет выведен отчет о проделанной операции:

.. code-block:: c

	$ mv -vt /home/user /var/tmp/myfile1.txt /var/tmp/myfile2.txt
	'/var/tmp/myfile1.txt' -> '/home/user/myfile1.txt'
	'/var/tmp/myfile2.txt' -> '/home/user/myfile2.txt'


Жесткие ссылки
--------------

Слово "ссылка" упоминалось, когда рассматривались директории и inode. На самом деле в линуксе существует два вида ссылок. Первый вид называют жесткими ссылками. Каждый inode может иметь несколько связанных с ним жестких ссылок. Таким образом, получается что файл присутствует в системе под несколькими разными именами. Файл существует до тех пор, пока с его inode связано хотя бы одно имя. Понятия «жёсткая ссылка на файл» и «имя файла» являются синонимами. Новые жесткие ссылки на файл можно сделать при помощи команды ln:

.. code-block:: c

	$ cd /tmp
	$ touch firstlink
	$ ln firstlink secondlink
	$ ls -i firstlink secondlink
	15782 firstlink    15782 secondlink


Как видно из примера, жесткие ссылки работают на уровне inode, указывая на определенный файл. В линуксе у жестких ссылок есть несколько ограничений. Во-первых, можно создавать жесткие ссылки только на файлы, но не на директории. Вот именно, несмотря на то, что в системе существуют жесткие ссылки на директории ('.' и '..'), даже суперпользователь не может создавать дополнительные жесткие ссылки на директории. Во-вторых, невозможно создать жесткую ссылку на файл находящийся в другой файловой системе, т.к. каждая файловая система имеет свой уникальный набор inode.


Символические ссылки
--------------------

На практике чаще применяют символические ссылки (или симлинки). Симлинк это специальный вид файла, который ссылается на другой файл по имени, а не напрямую на inode. Симлинки не предохраняют файл от удаления. Если файл удалить, то симлинк на него станет нерабочим (или битым).
Симлинки создаются командой ln с опцией '-s':

.. code-block:: c

	$ ln -s secondlink thirdlink
	$ ls -l firstlink secondlink thirdlink
	-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 firstlink
	-rw-rw-r--    2 agriffis agriffis        0 Dec 31 19:08 secondlink
	lrwxrwxrwx    1 agriffis agriffis       10 Dec 31 19:39 thirdlink -> secondlink


Символическую ссылку можно распознать по выводу команды ls -l: во-первых, в первой колонке у симлинков стоит буква 'l' (первая буква английского слова link–ссылка), во-вторых, размер симлинка равен количеству букв в имени файла на который он ссылается ('secondlink' в нашем случае), в-третьих, последняя колонка помимо имени ссылки содержит имя файла на который она ссылается после знака –>

Символические ссылки намного гибче жестких. С их помощью можно ссылаться на любой объект (файл, директория, сокет...) любой файловой системы.

Рассмотрим ситуацию, когда необходимо сделать симлинк который указывает на /usr/local/bin и находится в директории /tmp/:

.. code-block:: c

	$ ln -s /usr/local/bin bin1
	$ ls -l bin1
	lrwxrwxrwx    1 root     root           14 Jan  1 15:42 bin1 -> /usr/local/bin


Или

.. code-block:: c

	$ ln -s ../usr/local/bin bin2
	$ ls -l bin2
	lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -> ../usr/local/bin


Как видно из этих примеров, обе ссылки указывают на одну директорию. Но, если вторую ссылку переместить из /tmp в другую директорию, она может оказаться битой из-за использованного в ней относительного пути.

.. code-block:: c

	$ ls -l bin2
	lrwxrwxrwx    1 root     root           16 Jan  1 15:43 bin2 -> ../usr/local/bin
	$ mkdir mynewdir
	$ mv bin2 mynewdir
	$ cd mynewdir
	$ cd bin2
	bash: cd: bin2: No such file or directory


Так как не существует директории /tmp/usr/local/bin/, то невозможно сменить рабочую директорию на bin2; другими словами, после перемещения ссылка перестала работать (стала 'битой').
По этой причине, иногда стоит избегать создания симлинков, используя относительные пути. Но иногда это бывает удобно. Рассмотрим такой случай: допустим необходимо сделать ссылку на программу в /usr/bin (или другими словами присвоить этой программе альтернативное имя):

.. code-block:: c

	# ls -l /usr/bin/keychain 
	-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain


Суперпользователь (root) может захотеть сделать ссылку на программу "keychain" с более коротким именем "kc". В этом примере у нас есть рутовый доступ к системе, о чем свидетельствует приглашение bash, изменившееся на "#". Права суперпользователя также нужны потому, что обычные пользователи не могут создавать файлы в директории /usr/bin/. Теперь можно от имени рута создать альтернативное имя для keychain:

.. code-block:: c

	# cd /usr/bin
	# ln -s /usr/bin/keychain kc
	# ls -l keychain
	-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/bin/keychain
	# ls -l kc
	lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> /usr/bin/keychain


В этом примере был создан симлинк kc ссылающийся на файл /usr/bin/keychain.
Эта ссылка полностью рабочая, но она перестанет работать, если перенести оба файла 'keychain' и 'kc' из директории /usr/bin/ в /usr/local/bin/:

.. code-block:: c

	# mv /usr/bin/keychain /usr/bin/kc /usr/local/bin
	# ls -l /usr/local/bin/keychain
	-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
	# ls -l /usr/local/bin/kc
	lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> /usr/bin/keychain


Из-за того при создании ссылки был использован абсолютный путь, она продолжает указывать на файл /usr/bin/keychain, которого больше 
нет. Но если бы использовался относительный путь при создании ссылки, она бы осталась рабочей.
Итого, ссылки созданные с абсолютными и относительными путями имеют каждая свое применение. Поэтому при создании симлинка нужно выбрать способ, который будет уместнее в данной конкретной ситуации.
Часто оба вида симлинков (с абсолютными и относительным и путями) работают нормально. Следующий пример показывает способ создания симлинка, который продолжает работать после перемещения его и файла на который он ссылается в другую директорию:

.. code-block:: c


	# cd /usr/bin
	# ln -s keychain kc
	# ls -l kc
	lrwxrwxrwx    1 root     root            8 Jan  5 12:40 kc -> keychain
	# mv keychain kc /usr/local/bin
	# ls -l /usr/local/bin/keychain
	-rwxr-xr-x    1 root     root        10150 Dec 12 20:09 /usr/local/bin/keychain
	# ls -l /usr/local/bin/kc
	lrwxrwxrwx    1 root     root           17 Mar 27 17:44 kc -> keychain


Теперь можно запускать программу 'keychain', обратившись к ней по имени /usr/local/bin/kc

rm
--

Теперь после ознакомления с командами cp, mv и ln рассмотрим как удалять файлы. Обычно, удаление производится при помощи команды rm. Чтобы удалить несколько файлов, необходимо укаpfnm их имена через пробел в командной строке как аргументы rm:

.. code-block:: c

	$ cd /tmp
	$ touch file1 file2
	$ ls -l file1 file2
	-rw-r--r--    1 root     root            0 Jan  1 16:41 file1
	-rw-r--r--    1 root     root            0 Jan  1 16:41 file2
	$ rm file1 file2
	$ ls -l file1 file2
	ls: file1: No such file or directory
	ls: file2: No such file or directory


Удаленные файлы невозможно восстановить (хотя можно попробовать). Поэтому многие начинающие пользователи линукс используют опцию '-i' команды rm, которая требует запрашивать у пользователя подтверждение удаления каждого файла.

.. code-block:: c

	$ rm -i file1 file2
	rm: remove regular empty file `file1'? y
	rm: remove regular empty file `file2'? y


В последнем примере перед удалением каждого файла команда rm спрашивает: действительно ли пользователь хочет удалить файл? Чтобы подтвердить удаление, нудно нажать клавишу "y" на клавиатуре, а чтобы отказаться от удаления — клавишу "n".
Прервать выполнение любой команды (если что-то пошло не так как задумывалось) можно нажав комбинацию Ctrl–C.
Сделать так, чтобы команда rm запрашивала подтверждение на удаление каждого файла даже без опции '-i' можно добавив в файл ~/.bashrc с помощью любимого текстового редактора строку:

.. code-block:: c

	alias rm="rm -i"
	rmdir


Есть два способа удаления директорий: можно поочередно удалить все содержимое директории, а потом использовать команду rmdir для удаления самой директории:

.. code-block:: c

	$ mkdir mydir
	$ touch mydir/file1
	$ rm mydir/file1
	$ rmdir mydir


Этот способ обычно называют "метод удаления директорий для неудачников". Намного удобнее использовать команду 'rm -rf' для удаления директории со всем ее содержимым.

.. code-block:: c

	$ rm -rf mydir


Эту команду нужно использовать с осторожностью, так как с ее помощью неопытному администратору (тем более с правами администратора) очень легко удалить содержимое со всего жесткого диска.

Использование wildcards
-----------------------

При повседневном использовании часто возникают ситуации когда нужно выполнить одну простую операцию (например rm) над множеством файлов. В этом случае не очень удобно перечислять все имена файлов в командной строке:

.. code-block:: c

	$ rm file1 file2 file3 file4 file5 file6 file7 file8


Решить эту проблему можно при помощи шаблонов замены (wildcards). Командный интерпретатор поддерживает возможность указания множества файлов используя шаблоны (по историческим причинам это еще называют "globbing"). Bash и другие команды выбирают только те файлы, которые совпадают с шаблоном. Так, если нужно удалить файлы с file1 по file8, нужно написать:

.. code-block:: c

	$ rm file[1-8]


А если нужно удалить все файлы имена которых начинаются со слова file и файл с именем file:

.. code-block:: c

	$ rm file*


Шаблон * соответствует любому символу, последовательности символов или "отсутствию символа". Конечно, шаблоны можно применять не только для удаления файлов, как будет показано ниже.

Если необходимо вывести список файлов в директории /etc/ имена которых начинаются с буквы "g" и файл с именем "g" (если такой существует), нужно написать:

.. code-block:: c

	$ ls -d /etc/g*
	/etc/gconf  /etc/ggi  /etc/gimp  /etc/gnome  /etc/gnome-vfs-mime-magic  /etc/gpm  /etc/group  /etc/group-


Посмотрим что случится если указать шаблон который не совпадает ни с одним именем файла:

.. code-block:: c

	$ ls -d /usr/bin/asdf*jkl
	ls: /usr/bin/asdf*jkl: No such file or directory


В этом примере мы попытались вывести список файлов имена которых начинаются на "asdf" и заканчиваются на "jkl". Интерпретатор команд выдал сообщение что файлов с такими именами не найдено.

Синтаксис шаблона: \* и ?
-------------------------

Мы посмотрели как работает глоббинг (подстановка имен файлов). А теперь рассмотрим подробнее синтаксис шаблонов:

+ \* соответствует нулю или большему количеству символов:
    * /etc/g\* — все файлы в директории /etc/ имена которых начинаются с "g" и файл с именем "g".
    * /tmp/my\*1 — все файлы в директории /tmp имена которых начинаются с "my" и заканчиваются на "1" (включая файл с именем "my1")

+ \? заменяет один любой символ:
    * myfile\? — любой файл чье имя начинается со слова "myfile" за которым следует один любой символ.
    * /tmp/notes\?txt — соответствует файлам с именами "notes.txt" и "notes_txt" (если они существуют в /tmp/).


Квадратные скобки: []
---------------------

Шаблон '[]' очень похож на '?' но позволяет явно указывать набор символов. Шаблон '[]' совпадает с одним символом из тех что указаны в скобках. Также в скобках можно указать диапазон символов (для этого используется символ –/дефис) или несколько диапазонов подряд, тогда шаблон будет совпадать с одним любым символом из этого диапазона:

+ myfile[12] — соответствует myfile1 и myfile2. Шаблон будет работать пока существует хотя бы один из этих двух файлов.
+ [Cc]hange[Ll]og — соответствует файлам с именами Changelog, ChangeLog, changeLog, и changelog. Как вы могли заметить, использование шаблона [] полезно при поиске имен отличающихся регистром букв.
+ ls /etc/[0-9]* — вывести список файлов в директории /etc/ имена которых начинаются с цифры.
+ ls /tmp/[A-Za-z]* — вывести список файлов в директории /tmp/ имена которых начинаются с буквы (заглавной или прописной) Конструкция [[] похожа на [], за исключением того что она соответствует единичному символу, не упомянутому между [[ и ]. Например:
+ rm myfile[[9] — удалит все файлы, имена которых состоят из слова "myfile" и идущей за ним одной цифрой, кроме файла "myfile9".

Рассмотрим несколько примеров использования шаблонов. Так как bash интерпретирует символы ?, [, ], * как шаблоны замены, необходимо принять меры предосторожности при использовании аргументов содержащих эти символы. Например, если вы хотите создать файл, содержащий строку '[fo]*', то следующая команда сделает не то, что ожидается:

.. code-block:: c

	$ echo [fo]* > /tmp/mynewfile.txt


Если в рабочей директории найдется один или несколько файлов, имена которых попадают под шаблон '[fo]*', то в /tmp/mynewfile.txt будет список их имен, а не строка '[fo]*'. Существует несколько способов записать приведенную выше строку в файл. 
Первый способ — это взять строку в одинарные кавычки. К строке в одинарных кавычках bash относится как к обычной текстовой строке и не раскрывает символы замены.

.. code-block:: c

	$ echo '[fo]*' > /tmp/mynewfile.txt

После выполнения этой команды файл будет содержать строку '[fo]*' как и ожидалось. 
Другой способ — заэкранировать спец.символы с помощью обратного слэша (\). Бэкслэш стоящий перед спец.символом сообщает интерпретатору, что этот символ нужно рассматривать как обычный текст а не как шаблон.

.. code-block:: c

	$ echo \[fo\]\* > /tmp/mynewfile.txt


Оба предложенных метода (одинарные кавычки и экранирование) дают желаемый результат. Чтобы указать текстовый символ "\" можно заключить его в одинарные кавычки или написать "\\\" (эта комбинация будет воспринята интерпретатором как обычный одинарный бэкслэш "\").

Замечание: Двойные кавычки работаю почти так же как и одинарные, но позволяют bash-у интерпретировать некоторые спец.символы. Поэтому одинарные кавычки — лучший способ передать команде только текст. Для дополнительной информации о шаблонах читайте справку 'man 7 glob'. Для дополнительной информации об использовании кавычек, читайте раздел QUOTING справки 'man 8 glob'.


Переменные окружения
====================

Окружение (environment) или среда - это набор пар ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ, доступный каждому пользовательскому процессу. Иными словами, окружение - это набор переменных окружения. Если вы используете оболочку, отличную от bash, то не все примеры этой главы могут быть воспроизведены.

Для того, чтобы посмотреть окружение, просто введите команду env без аргументов. В зависимости от конфигурации системы, вывод env может занять несколько экранов, поэтому лучше сделать так:

.. code-block:: c

	$ env | more


Или так:

.. code-block:: c

	$ env | less


Переменные окружения могут формироваться как из заглавных, так и из строчных символов, однако исторически сложилось именовать их в верхнем регистре. Мы также не будем отступать от этого неписанного правила.
Про полезность окружения можно говорить долго, но основное его назначение - заставить одни и те же программы работать у разных пользователей по-разному. Приятно, например, когда программа "угадывает" имя пользователя или домашний каталог пользователя. Чаще всего такая информация "добывается" из переменных окружения USER и HOME соответственно.

Значение каждой переменной окружения изначально представляет собой строковую константу (строку). Интерпретация значений переменных полностью возлагается на программу. Иными словами, все переменные окружения имеют тип char*, а само окружение имеет тип char**. Чтобы вывести на экран значение какой-нибудь переменной окружения, достаточно набрать echo $ИМЯ_ПЕРЕМЕННОЙ:

.. code-block:: c
	
	$ echo $USER
	$ user
	$ echo $HOME
	$ /home/user


При работе с оболочкой bash, запись $ИМЯ_ПЕРЕМЕННОЙ заменяется на само значение переменной, если только эта запись не встречается в кавычках, апострофах или в комментариях. В данном случае, например, запись $HOME заменяется на /home/user. То есть команда mkdir $HOME/mynewdir создаст в моем домашнем каталоге подкаталог mynewdir.
В разных системах и у разных пользователей окружение отличается не только значениями переменных, но и наличием/отсутствием этих переменных. Пользователи, использующие универсальные MUA (Mail User Agent), наподобие Mozilla-mail, Kmail или Sylpheed вряд ли будут иметь в своем окружении (по крайней мере с пользой) переменные MAIL или MAILDIR. А пользователям mutt, pine или elm (с надстройками в виде fetchmail/getmail, procmail и проч.) эти переменные жизненно необходимы. Пользователь, не использующий графические оболочки, вряд ли будет иметь в своем окружении переменную QTDIR. Ниже приведены те переменные окружения, которые есть почти у всех пользователей Linux:

* USER - имя текущего пользователя
* HOME - путь к домашнему каталогу текущего пользователя
* PATH - список каталогов, разделенных двоеточиями, в которых производится "поиск" программ
* PWD - текущий каталог
* OLDPWD - предыдущий текущий каталог
* TERM - тип терминала
* SHELL - текущая командная оболочка

Некоторые переменные окружения имеются не во всех системах, но все-таки требуют упоминания:

* HOSTNAME - имя машины
* QTDIR - расположение библиотеки QT
* MAIL - почтовый ящик
* LD_LIBRARY_PATH - место "поиска" дополнительных библиотек
* MANPATH - место поиска файлов man-страниц (каталоги, разделенные двоеточием)
* LANG - язык и кодировка пользователя (иногда LANGUAGE)
* DISPLAY - текущий дисплей в X11

Чтобы задать переменную оболочки, достаточно написать в командной строке ПЕРЕМЕННАЯ=ЗНАЧЕНИЕ.

.. code-block:: c

	$ MYVAR=Hello
	$ echo $MYVAR
	Hello
	$ env | grep MYVAR
	$

Однако, при желании, можно включить локальную переменную оболочки в основное окружение. Для этого используется команда export:

.. code-block:: c

	$ export MYVAR
	$ env | grep MYVAR
	MYVAR=Hello
	$	

Можно сделать сразу так:

.. code-block:: c

	$ export MYNEWVAR=Goodbye
	$ echo $MYNEWVAR
	Goodbye
	$ env | grep MYNEWVAR
	MYNEWVAR=Goodbye
	$

Для удаления переменной окружения используется команда unset:

.. code-block:: c

	$ unset MYNEWVAR
	$ echo $MYNEWVAR
	$
	$ env | grep MYNEWVAR
	$

Прежде, чем продолжать дальше, попробуйте поэкспериментировать с переменными окружения, чтобы лучше все понять. Выясните экспериментальным путем, чувствительны ли к регистру символов переменные окружения; можно ли использовать в качестве значений переменных окружения строки, содержащие пробелы; если можно, то как?

Теперь разберемся с тем, откуда берется окружение. Любая запущенная и работающая в Linux программа - это процесс. Запуская дважды одну и ту же программу, вы получаете два процесса. У каждого процесса (кроме init) есть свой процесс-родитель. Когда вы набираете в командной строке vim, в системе появляется новый процесс, соотвествующий текстовому редактору vim; родительским процессом здесь будет оболочка (bash, например). Для самой оболочки новый процесс будет дочерним. Новый процесс получает копию родительского окружения, причем у каждого процесса своя независимая копия окружения, с которой он может делать все что угодно. Если процесс завершается, то копия теряется; если процесс породил другой, дочерний процесс, то этот новый процесс получает копию окружения своего родителя. 


Рассмотрим более сложные манипуляции с переменными. Первым шагом будет парсинг строки - разделение её на более короткие составляющие. Это одна из частых операций, встречающихся при написании shell-скриптов. Иногда скрипту нужно определить имя конкретного файла или директории, зная полный (абсолютный) путь к нему. На bash это можно сделать всего одной командой:

.. code-block:: c

	$ basename /usr/local/share/doc/foo/foo.txt
	foo.txt
	$ basename /usr/home/drobbins
	drobbins


'basename' — очень удобная утилита для расщепления строк на составляющие. Вторая команда — 'dirname' — возвращает другую часть строки (путь к директории где находится файл):

.. code-block:: c

	$ dirname /usr/local/share/doc/foo/foo.txt
	/usr/local/share/doc/foo
	$ dirname /usr/home/drobbins/
	/usr/home



Иногда требуется присвоить переменной результат выполнения какой-либо команды. Делается это следующим образом:

.. code-block:: c

	$ MYDIR=$(dirname /usr/local/share/doc/foo/foo.txt)
	$ echo $MYDIR
	/usr/local/share/doc/foo

То же самое можно сделать заменив конструкцию $(команда) на \`команда\`:

.. code-block:: c

	$ MYDIR=`dirname /usr/local/share/doc/foo/foo.txt`
	$ echo $MYDIR
	/use/local/share/doc/foo



Бывают случаи, когда нужно произвести более сложные операции над строками чем манипуляции с путями. Для более эффективной работы со строками можно использовать встроенные средства подстановки значений переменных bash:

.. code-block:: c

	$ MYVAR=foodforthought.jpg
	$ echo ${MYVAR##*fo}
	rthought.jpg
	$ echo ${MYVAR#*fo}
	odforthought.jpg


Рассмотрим подробнее конструкцию \${MYVAR\#\#\*fo} из предыдущего примера. Bash взял переменную 'MYVAR', нашел наибольшую по длине подстроку строки 'foodforthought.jpg' (начиная от начала строки) которая совпала с шаблоном "\*fo" и удалил ее. Для того чтобы понять как работает конструкция \#\#, рассмотрим пошагово как bash ищет совпадение подстроки с шаблоном. Начинаем поиск подстроки совпадающей с шаблоном "\*fo" с начала строки "foodforthought.jpg". Вот список всех таких подстрок: 

.. code-block:: c

	f
	fo              совпадает с шаблоном "*fo"
	foo
	food
	foodf
	foodfo          совпадает с шаблоном "*fo"
	foodfor
	foodfort
	foodforth
	foodfortho
	foodforthou
	foodforthoug
	foodforthought
	foodforthought.j
	foodforthought.jp
	foodforthought.jpg


После проверки всех этих вариантов, найдено две строки попадающие под шаблон. Bash выбирает самую длинную из них, а затем удаляет эту подстроку и возвращает результат.

Вторая форма подстановки переменной показанная в примере отличается от первой только наличием одного знака хэша (#), а не двух. И bash выполняет те же действия, за исключением того, что удаляет не самую длинную, а самую короткую из совпавших с шаблоном подстрок. Как видно, после удаления самой короткой подстроки совпавшей с шаблоном (fo) у нас остается строка "odforthought.jpg".

Чтобы удалить последовательность символов от конца строки нужно воспользоваться знаком (%):

.. code-block:: c

	$ MYFOO="chickensoup.tar.gz"
	$ echo ${MYFOO%%.*}
	chickensoup
	$ echo ${MYFOO%.*}
	chickensoup.tar


Одинарный и двойной знаки процента (% и %%) работают также как "#" и "##", но удаляют подстроку совпавшую с шаблоном от конца строки. Можно не использовать знак "*", если вы хотите удалить какое-то конкретное окончание строки:

.. code-block:: c

	$ MYFOOD="chickensoup"
	$ echo ${MYFOOD%%soup}
	chicken

В этом примере нет разницы использовать % или %%, т.к. есть только одно совпадение. 
Можно использовать еще одну форму подстановки значения переменной для выделения подстроки по заданной длине и позиции начала:

.. code-block:: c

	$ EXCLAIM=cowabunga
	$ echo ${EXCLAIM:0:3}
	cow
	$ echo ${EXCLAIM:3:7}
	abunga


Эта форма очень удобна. Просто укажите разделяя двоеточиями позицию начала подстроки — первое число и длину подстроки — второе число.


bash скрипты
============

Теперь напишем небольшой shell-скрипт, который будет принимать один аргумент — имя файла и если этот файл имеет расширение .tar, скрипт будет сообщать что это тарбол (на самом деле определять тип файла по расширению не совсем корректно. Для этих целей существует команда file. Пример только для демонстрации.):

.. code-block:: c

	#!/bin/bash

	if [ "${1##*.}" = "tar" ]
	then
	       echo "Кажется это тарбол."
	else
	       echo "На первый взгляд, это не похоже на тарбол."
	fi


Первая строка обязательно должна присутствовать в каждом скрипте. Она показывает путь к интерпретатору, который будет выполнять скрипт. Ее синтаксис, как видно из примера — "#!<путь к интерпретатору>".
Сохраните текст скрипта из примера в файл mytar.sh, затем измените права доступа к нему 'chmod 755 mytar.sh' (это сделает файл исполняемым). И, наконец, запустите скрипт с аргументом в виде имени файла, как показано в следующем примере:

.. code-block:: c

	$ ./mytar.sh thisfile.tar
	Кажется это тарбол.
	$ ./mytar.sh thatfile.gz
	На первый взгляд, это не похоже на тарбол.


Рассмотрим конструкцию if, использованную в скрипте. В квадратных скобках сравниваются две строки ("=" — это оператор сравнения в bash). Результат сравнения — булевое выражение 'false' или 'true'. Посмотрим какие именно строки сравниваются. Справа — строка "tar". Слева стоит разобранное выше выражение, удаляющее начало строки в переменной $1 по шаблону "\*." (вся строка до последней точки, т.к. используются два хэша \#\#). После этой операции подстановки остается только часть строки после последней точки — расширение. Если в переменной \$1 содержится имя файла с расширением "tar", то результатом сравнения строк будет булевое true.
Переменная \$1 содержит в себе первый аргумент переданный скрипту (\$2 — второй аргумент и так далее).
Cлова "if" и "then" должны находится на разных строках. Рекомендуется выравнивать горизонтально всю конструкцию, включая заключительный "fi" и все "else". Это делает код намного удобнее для чтения и отладки. 

.. code-block:: c

	if      [ условие ]
	then 
	        действие
	fi

В дополнении к простой форме "if,else" есть еще несколько других форм условных конструкций. В приведенном выше примере 'действие' выполняется только если 'условие' верно, в противном случае скрипт продолжает выполнение инструкций со строки идущей за "fi".

.. code-block:: c

	if [ условие ]
	then 
	        действие
	elif [ условие_2 ]
	then
	        действие_2
	elif [ условие_3 ]
	then
	.
	.
	.
	else
	        действие_x
	fi


Эта конструкция последовательно проверяет условия и если они верны, то исполняет соответствующее действие. Если ни одно из условий не верно, то выполняется 'действие_x' стоящее после 'else' (если оно есть). Потом продолжается исполнение команд идущих за этой конструкцией "if,then,else", если таковые есть.

В bash есть операторы, упрощающие операции сравнения с файлами и строками:

Файлы
* -a file - истинно если файл существует.
* -d file - истинно если файл существует и является директорией.
* -f file - истинно если файл существует и является обычным файлом.
* -r file - истинно если файл существует и доступен для чтения.
* -s file - истинно если файл существует и его размер больше 0.
* -w file - истинно если файл существует и доступен для записи.
* -x file - истинно если файл существует и является исполняемым.
* file1 -nt file2 - истинно если файл file1 новее чем file2 или file1 (в соответствии со временем последнего изменения) существует, а file2 нет.
* file1 -ot file2 -истинно если файл file1 старше чем file2 или file2 существует, а file1 нет.
* file1 -ef file2 -истинно если оба файла ссылаются на одно и то же устройство или inode.

Строки
* -z string - истинно если строка имеет нулевую длину.
* -n string - истинно если длина строки не нулевая.
* string1 = string2 - истинно если строки равны.
* string1 != string2 - истинно если не равны.
* string1 < string2 - истинно если строка 1 стоит в алфавитном порядке перед строкой 2.
* string1 > string2 - истинно если строка 1 стоит в алфавитном порядке после строки 2.

В следующих примерах показано как использовать оператор сравнения в конструкции "if":

.. code-block:: c

	if [ -z "$myvar" ]
	then
		echo "Переменная 'myvar' не определена."

	fi

Квадратные скобки вычисляют условное выражение стоящее в них (это синоним встроенной функции bash — test). Возвращаемый результат — 1 или 0 в зависимости от того выполняется условие или нет. в скобках может стоять несколько выражений, связанных логическими операторами "и" или "или".
В некоторых случаях одна и та же операция сравнения может быть сделана несколькими разными способами. Обе конструкции из следующего примера функционально идентичны:

.. code-block:: c

	if [ "$myvar" -eq 3 ]
	then 
	     echo "myvar равно 3"
	fi

	if [ "$myvar" = "3" ]
	then
	     echo "myvar равно 3"
	fi


В первой конструкции из предыдущего примера использована операция арифметического сравнения, а во втором — операция сравнения строк.
В большинстве случаев, если не заключаеть строки и строковые переменные в двойные кавычки, это может привести к ошибке. Это происходит потому что в строке может встретится пробел или символ табуляции, которые bash не сможет правильно обработать. Вот пример некорректного сравнения строк:

.. code-block:: c

	if [ $myvar = "foo bar oni" ]
	then
	     echo "yes"
	fi


Если значение переменной "$myvar" будет равно "foo", код будет работать как и ожидается и не печатать ничего. Но если значение переменной "$myvar" будет равно "foo bar oni", скрипт вызовет следующую ошибку:

.. code-block:: c

	[: too many arguments


После подстановки значения переменной, bash пытается произвести следующую операцию сравнения:

.. code-block:: c

	[ foo bar oni = "foo bar oni" ]

В этом случае bash не может правильно обработать сравнение строк содержащих пробелы, одна из которых не заключена в двойные кавычки. Интерпретатор думает, что в квадратных скобках слишком много аргументов. После заключения переменной в двойные кавычки, ошибка не возникает и код работает так как задумывалось. Исправленный фрагмент кода:

.. code-block:: c

	if [ "$myvar" = "foo bar oni" ]
	then
	    echo "yes"
	fi


Этот код будет работать корректно и не преподнесет больше никаких неприятных сюрпризов.

Замечание: Для того чтобы подстановка значений переменных продолжала работать, необходимо заключать их в двойные кавычки, а не в одинарные. Одинарные кавычки отключают подстановку значения переменных.

Конструкция создания циклов "for"
---------------------------------

Рассмотрим управляющую конструкцию "for". Вот стандартный пример:

.. code-block:: c

	#!/bin/bash

	for x in one two three four
	do
	    echo "number $x"
	done

	Результат:
	number one
	number two 
	number three 
	number four


Часть "for x" цикла "for" определяет переменную (называемую итератором) "$x", которая последовательно принимает значения "one", "two", "three", и "four" (по одному за один такт цикла). После присвоения каждого нового значения переменной "$x", выполняется тело цикла (код между словами "do" и "done"). В теле цикла выводится на печать значение переменной "$x". Заметим, что после слова "in" в конструкции "for" всегда стоит некий список. В данном примере мы указали четыре слова, но этот список может содержать имена файлов или даже шаблон (wildcard). В следующем примере показано как использовать шаблоны при инициализации итератора цикла:

.. code-block:: c

	#!/bin/bash

	for myfile in /etc/r*
	do
	    if [ -d "$myfile" ] 
	    then
	      echo "$myfile (dir)"
	    else
	      echo "$myfile"
	    fi
	done

	Результат:
	/etc/rc0.d (dir)
	/etc/rc1.d (dir)
	/etc/rc2.d (dir)
	/etc/rc3.d (dir)
	/etc/rc4.d (dir)
	/etc/rc5.d (dir)
	/etc/rc6.d (dir)
	/etc/rc.local
	/etc/rcS.d (dir)
	/etc/rearj.cfg
	/etc/reportbug.conf
	/etc/resolvconf (dir)
	/etc/resolv.conf
	/etc/rmt
	/etc/rpc
	/etc/rsyslog.conf
	/etc/rsyslog.d (dir)

Код этого цикла исполнится для каждого файла из /etc/ имя которого начинается с "r". Сначала bash найдет все такие файлы и заменит шаблон строкой /etc/rc0.d /etc/rc1.d /etc/rc2.d /etc/rc3.d /etc/rc4.d ... /etc/rsyslog.d перед тем как приступить к выполнению цикла. В теле цикла для каждого файла из списка проверяется является ли этот файл директорией при помощи оператора "-d". Если файл оказался директорией, рядом с его называнием печатается "(dir)".

В списке инициализации итератора можно использовать несколько шаблонов одновременно и даже переменные окружения:

.. code-block:: c

	for x in /etc/r??? /var/lo* /home/drobbins/mystuff/* /tmp/${MYPATH}/*
	do
	    cp $x /mnt/mydira
	done

Bash в этом примере подставляет значение переменной и раскрывает шаблоны. А затем копирует все файлы в заданную директорию.
До этого все примеры содержали шаблоны основанные на абсолютных путях, но можно использовать и относительные:

.. code-block:: c

	for x in ../* mystuff/*
	do
	     echo "$x is a silly file"
	done


В этом примере bash раскрывает шаблон относительно текущей рабочей директории (не той в которой находится скрипт, а той которую показывает команда "pwd"). Поиграйтесь с этим скриптом, позапускайте его из разных директорий и посмотрите на результат.
Иногда может потребоваться запустить цикл по списку аргументов из командной строки. Вот как это делается:

.. code-block:: c

	#!/bin/bash

	for i in "$@"
	do
	    echo "Вы написали: ${i}."
	done

	результат:
	$ ./test.sh hello there you silly
	Вы написали: hello.
	Вы написали: there.
	Вы написали: you.
	Вы написали: silly.

	В этом примере мы использовали переменную "$@", значение которой равно кол-ву аргументов, переданных скрипту.

Арифметика в shell
------------------

Перед тем как приступить к разбору следующего вида циклической конструкции, научимся при помощи интерпретатора производить простые арифметические операции. Просто заключите арифметическое выражение в конструкцию "$(( ))" и bash посчитает ее значение. Вот несколько примеров:

.. code-block:: c

	$ echo $(( 100 / 3 ))
	33
	$ myvar="56"
	$ echo $(( $myvar + 12 ))
	68
	$ echo $(( $myvar - $myvar ))
	0
	$ myvar=$(( $myvar + 1 ))
	$ echo $myvar
	57

Теперь, рассмотрим циклические конструкциии "while" и "until".
"while"–цикл исполняется пока выражение в квадратных скобках истинно. Он имеет следующий формат:

.. code-block:: c

	while [ условие ]
	do
	    код
	done


В следующем примере тело цикла исполняется ровно 10 раз:

.. code-block:: c

	myvar=0
	while [ $myvar -ne 10 ]
	do
	    echo "$myvar"
	    myvar=$(( $myvar + 1 ))
	done


После каждого выполнения кода тела цикла переменная "myvar" увеличивается на 1. Когда значение переменной становится равным 10, условие в квадратных скобках не выполняется и цикл прерывается.
"Until"–цикл очень похож на "while"–цикл: он повторяется пока выражение в квадратных скобках ложно. Вот пример "until"–цикла по функциональности идентичного "while"–циклу из предыдущего примера:

.. code-block:: c

	myvar=0
	until [ $myvar -eq 10 ]
	do
	    echo $myvar
	    myvar=$(( $myvar + 1 ))
	done


Экстренный выход из цикла
Для экстренного выхода из "for", "while" или "until" цикла используется команда break. Для выхода из нескольких вложенных циклов — break N, где N — количество вложенных циклов.

.. code-block:: c

	name=0
	while :
	do
	   wget http://example.com/gallery/${name}.png
	   [ $? -ne 0 ] && break
	done


В последнем примере: "while :" — бесконечный цикл. Двоеточие — это команда bash которая не делает ничего но всегда завершается успехом. Переменная $? содержит статус с которым завершилась последняя команда (подробнее о специальных переменных описано в man bash). В нашем случае код отличный от 0 обозначает что при скачивании файла произошла ошибка. Как только условие в квадратных скобках выполнено, интерпретатор переходит к исполнению команды стоящей после логического и (&&). Break прерывает выполнение цикла.
Предпоследнюю строку предыдущего примера можно заменить на условную конструкцию "if":

.. code-block:: c

	[ $? -ne 0 ] && break
	то же самое но через условную конструкцию:
	if [ $? -ne 0 ]
	then
	      break
	fi


Или в одну строку

.. code-block:: c

	if [ $? -ne 0 ]; then break; fi


Условную, конструкцию можно записывать в одну строку, только нужно поставить несколько разделяющих знаков ";". 

Команда–переключатель "case"
----------------------------

Конструкция условного перехода "case" может оказаться очень полезной. Вот пример ее использования:

.. code-block:: c

	case "${x##*.}" in
		gz)  gzunpack ${SROOT}/${x} ;;
		bz2) bz2unpack ${SROOT}/${x} ;;
		*)   echo "Формат архива не определен."
		exit
		;;
	esac


В этом примере сначала происходит обработка строки в переменной "$x" — "${x##*.}". После этой операции в переменной "$x" остается только расширение файла. Затем bash сравнивает это расширение с вариантами стоящими слева от одинарных скобок ")". Если совпадение найдено, выполняется соответствующее действие. Если совпадения не найдено, никаких действий не выполняется, но в данном конкретном коде совпадение будет всегда, потому что в последней строке стоит шаблон "*", совпадающий с любой последовательностью символов.



Задание
-------

Разработать скрипт, который принимает в качестве аргументов два параметра: первое расширение файла, второе расширение файла,
находит в текущем каталоге все файлы с первым расширением и переименовывает их так, что меняет их расширение на второе расширение.
Если таких файлов не существует, выводит сообщение об ошибке
Если кол-во аргументов не равно 2, то скрипт завершает свою работу с сообщением об ошибке.