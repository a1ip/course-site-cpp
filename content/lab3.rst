Передача параметров в функции   
#############################

:date: 2016-09-15 09:00
:status: draft

.. default-role:: code
.. contents:: Содержание

	
Функции с параметрами в С++
===========================

Исходные данные функция должена получать из своих параметров.
Список параметров в заголовке функции называется *список формальных параметров*.

Параметр функции — это принятый функцией аргумент, значение, переданное из вызывающего кода.

Различают:

* фактический параметр — что именно передали в функцию при её вызове (в частности, на этапе выполнения программы);
* формальный параметр — аргумент, указываемый при объявлении и определении функции.

Пример функции с одним параметром:
 
.. code-block:: c

	// Объявление функции.
	// int a - формальный параметр (имя параметра может отсутствовать).
	int my_function(int a);
	 
	// Определение функции.
	// int b - формальный параметр (имя параметра может не совпадать с указанным при объявлении функции)
	int my_function(int b)
	{
	   return b + 1;
	}
	 
	int main()
	{
		int c = 0;
		my_function(c); // Вызов функции. c - фактический параметр.
		return 0;
	}

Передача параметра по значению
------------------------------

Параметры в С++ передаются *по значению*: вызывающая функция копирует в память, доступную вызываемой функции (сегмент стека), непосредственное фактическое значение.

Изменение копии переменной, соответственно, оригинал не затрагивает!

Упражнение №1
+++++++++++++

.. code-block:: c

	void bad_incrementor(int x)
	{
		x++;
		std::cout << 'x changed: ' << x << std::endl;
	}

Вызвать функцию `bad_incrementor()`, которая изменяет формальный параметр, и убедиться в том, что фактический параметр неизменен.


Передача параметра по адресу
----------------------------

Чтобы изменить переменную изнутри функции, можно передавать ей не значение, а *адрес переменной*, подлежащей изменению. При вызове такой функции приходится использовать операцию взятия адреса. Например: `g(&x)`.

Передача параметра по адресу является частным случаем передачи по значению: передаваемым значением является адрес, по которому можно найти другое значение — значение переменной `x`.

Упражнение №2
+++++++++++++

Описать функцию `good_incrementor()` в соответствии с прототипом.
Она должна увеличивать значение переменной x на 1.

.. code-block:: c

	void good_incrementor(int *x);
	
	int main()
	{
		int x = 1;
		std::cout << 'x initial: ' << x << std::endl;
		good_incrementor(&x);
		std::cout << 'x changed: ' << x << std::endl;
		
		return 0;
	}

Не забывайте, что в теле функции x — это *указатель*, который при обращении нужно разыменовывать.

Передача параметра по ссылке
----------------------------

Упражнение №3
+++++++++++++

Описать функцию `better_incrementor()` в соответствии с прототипом.
Она также должна увеличивать значение переменной x на 1.

.. code-block:: c

	void good_incrementor(int &x);

Проверьте её работоспособность.
Не забудьте, что ссылку в теле функции не нужно разыменовывать, а при вызове не требуется передавать адрес.


Прототипы функций
=================

**Определение функции** содержит как *заголовок*, так и *тело функции*:

Благодаря принципу *раздельной компиляции*, на самом этапе компиляции *не требуется тело функции* — достаточно только заголовка.

**Прототипом** функции в языке Си или C++ называется *объявление функции*, не содержащее тела функции, но указывающее:

* имя функции,
* количество аргументов (арность),
* типы аргументов,
* возвращаемый тип данных.

В то время как определение функции описывает, *что именно* делает функция, прототип функции — это описание её *интерфейса*.

.. code-block:: c

	double new_style(int a, double *x); /* прототип функции */

Обратите внимание на точку с запятой после закрывающей круглой скобки. Она значит, что тела функции тут не предполагается.

В прототипе имена аргументов являются необязательными, тем не менее, необходимо указывать тип вместе со всеми модификаторами (например, если это указатель или константный аргумент):

.. code-block:: c

	double alt_style(int, double *); /* альтернативная форма прототипа */

На этапе компоновки тело функции всё-таки понадобится, иначе программу не удастся собрать.

Протипы функций модуля (отдельной `единицы трансляции`_ программы) выделяют в **заголовочный файл** `.h`.
Прототип при компиляции должен находиться выше по тексту, чем место использования функции, поэтому подключение (`include`) заголовочных файлов происходит в самом начале файла `.cpp`, использующего данный модуль.

.. _`единицы трансляции`: https://ru.wikipedia.org/wiki/%D0%95%D0%B4%D0%B8%D0%BD%D0%B8%D1%86%D0%B0_%D1%82%D1%80%D0%B0%D0%BD%D1%81%D0%BB%D1%8F%D1%86%D0%B8%D0%B8

Квалификатор типа const
=======================

Для гарантии неизменности переменной можно использовать квалификатор const.

const и скалярные переменные
----------------------------

.. code-block:: c

	const int hello = 3;

`const` перед `hello` означает, что *во время компиляции* происходит проверка, что переменная `hello` никогда не меняется.

Если вы попытаетесь изменить или переопределить `hello`, компилятор остановит вас:

.. code-block:: text

	gcc-5.3.0:
	error: increment of read-only variable 'hello'
		 hello++;
			  ^
	error: assignment of read-only variable 'hello'
		 hello = 92;
			   ^


Кроме того, C++ не сильно беспокоится о том, где расположен `const` до тех пор пока он находится перед идентификатором, так что объявления `const int` и `int const` идентичны:

.. code-block:: c

	const int hello = 3;
	int const hello = 3;

const и массивы
---------------

Вы можете указать const для всего массива.

.. code-block:: c

	const int numbers[] = {1, 2, 3, 4, 5};


const также может указываться после объявления типа:

.. code-block:: c

	int const numbers[] = {1, 2, 3, 4, 5};


Если вы попытаетесь изменить `numbers[]`, компилятор остановит вас:

.. code-block:: text

	gcc-5.3.0:
	error: assignment of read-only location 'numbers[3]'
		 numbers[3] = 12;
               ^

const и указатели
-----------------

`const` для указателей — вот где основные сложности!

Нужно быть осторожным в определении *места расположения* для `const`, поскольку это повлияет на то, *что именно будет константой* - или сам указатель будет константой, или константой будет то место, *на которое* указатель указывает.

Например, выражение:

.. code-block:: c

	const int * constant_1; // указатель на константу
	int const * constant_2; // альтернативная запись указателя на константу

декларирует указатели с именами `constant_1` и `constant_2`, которые указывают на какое-то постоянное значение типа `int`. Т. е. *сам указатель изменять можно*, но значение, на которое указывает указатель, изменять нельзя.


А это выражение:

.. code-block:: c

	int * const constant_3; // константный указатель на переменную

декларирует, что `constant_3` является *постоянным указателем* на некоторую переменную `int`. Т. е. значение указателя будет всегда неизменным, а значение переменной, на которую указывает указатель, менять можно.

Внимание, двойной `const`:

.. code-block:: c

	int const * const constant_4; // константный указатель на константу

декларирует, что constant_4 является постоянным указателем, указывающим на постоянный `int`. Просто запомните, что `const` прикладывается непосредственно к объекту слева от `const` (кроме случая, когда слева от `const` нет ничего; тогда `const` прикладывается непосредственно к тому, что справа от него).

Общие слова про `const`
-----------------------

Объявление `const` не изменяет поведение программы, а действия с `const` проверяются только во время компиляции.
`const` существует, чтобы помочь людям справиться со сложностями, немного легче:

* помогает самодокументированию ожидаемого поведения переменных и параметров (служит простой защитой, если вы забудете что должно и не должно изменяться в будущем)

* const всегда можно обойти с помощью явного приведения типов или копирования памяти.

	Ваш компилятор по своему усмотрению может решить разместить неизменяемые переменные в месте доступном только для чтения, так что если вы попытаетесь обойти `const` вы можете столкнуться с неопределенным поведением.

Факультативно: *дополнительный материал про тройной `const` в `заметке на habrahabr`_.*

.. _`заметке на habrahabr`: https://habrahabr.ru/post/301332/


Динамически выделяемая память
=============================

Для работы вычислительного процесса, начиная с самого первого отведенного ему такта процессорного времени, нужна оперативная память.

Загрузчик операционной системы еще до запуска процесса (программы) на исполнение размещает в выделенной системой памяти страницы сегментов *CODE*, *DATA* и *STACK*. Размеры этих сегментов во время работы процесса не изменяются.

Вычислительный процесс может явным образом попросить у операционной системы дополнительную память.
При этом динимическая память является ресурсом операционной системой и выделяется по явному запросу процесса.
Выделенная память называется "куча" или *HEAP*.

Контроль за выделением и освобождением динамической памяти — дело рук программиста. Компилятор снимает с себя ответственность за то, что память выделена, но не освобождена, или же не выделена к необходимому моменту.

Выделение памяти в стиле Си (`malloc()` и `free()`)
---------------------------------------------------

Диалог между ОС и процессом по поводу памяти происходит через системные вызовы `malloc()` и `free()`. Данные функции определены в библиотеке `<stdlib.h>`:

.. code-block:: c

	void * malloc(size_t size); //функция выделения памяти

	void free(void * ptr); //функция освобождения памяти

Здесь:

* `size_t` – размер выделяемой области памяти в байтах;
* `void *` - обобщенный тип указателя, т.е. не привязанный к какому-либо конкретному типу.

Если выделение не произошло (то есть ОС отказала программе в выдаче дополнительной динамической памяти), `malloc()` возвращает значение адреса `NULL`.

Пример работы функций malloc() и free()
+++++++++++++++++++++++++++++++++++++++

.. code-block:: c

	#include <stdlib.h>
	#include <stdio.h>

	int main()
	{
		double *pd = (double *)malloc(10 * sizeof(double));
		if(pd != NULL)
		{
			//адресная арифметика обеспечит перебор адресов
			// от pd до pd + 9*sizeof(double) включительно
			for(double *p = pd; p < pd + 10; p++)
				*p = 0.0; //зануляем ячейку памяти типа double
		} else {
			printf("Не удалось выделить память.");
		}
		free(pd);
		return 0;
	}

Заметим, что у десяти ячеек памяти, которые мы использовали как ячейки типа `double`, вообще *не существует собственных имен*, работа с ними возможна *только по адресу*, хранящемуся в каком-либо указателе.

Корректность интерепретации данных обеспечивается сохранением в типе указателя информации о типе значения на которое он указывает.

Ошибки при работе с динамической памятью
----------------------------------------

Ошибка сегментации (Segmentation fault)
+++++++++++++++++++++++++++++++++++++++

.. code-block:: c

	#include <stdio.h>
	#include <stdlib.h>

	void foo(int *pointer)
	{
		*pointer = 0; //потенциальный Segmentation fault
	}

	int main()
	{
		int *p;
		int x;
		*NULL = 10; //совсем очевидный Segmentation fault
		*p = 10; //достаточно очевидный Segmentation fault
		foo(NULL); //скрытый Segmentation fault
		scanf("%d", x); //скрытый и очень популярный у новичков на Си Segmentation fault
	   
		return 0;
	}

Если процесс попытается использовать "чужую" память (что в защищенном режиме работы процессора в принципе невозможно из-за механизма виртуальной адрессации), обратившись по некоторму случайному адресу, операционная система аварийно завершит процесс с выводом предупреждения пользователю.

Утечка памяти (Memory leak)
+++++++++++++++++++++++++++

Если процесс попросил у ОС память, а затем про нее забыл и более не использует, это называется утечкой памяти.

Утечки памяти не являются критической ошибкой и в небольшом масштабе допустимы, если процесс работает очень недолго (секунды). Однако при разработке сколько-нибудь масштабируемого и выполняющегося продолжительное время приложения, допущение даже маленьких утечек памяти — серьезная ошибка.

.. code-block:: c

	#include <stdio.h>
	#include <stdlib.h>

	void swap_arrays(int *A, int *B, size_t N)
	{
		int * tmp = (int *) malloc(sizeof(int)*N); //временный массив
		for(size_t i = 0; i < N; i++)
			tmp [i] = A[i];
		for(size_t i = 0; i < N; i++)
			A[i] = B[i];
		for(size_t i = 0; i < N; i++)
			B[i] = tmp [i];
		//выходя из функции, забыли освободить память временного массива
	}

	int main()
	{
		int A[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
		int B[10] = {10, 9, 8, 7, 6, 5, 4, 3, 2, 1};
		swap_arrays(A, B, 10); //функция swap_arrays() имеет утечку памяти

		int *p;
		for(int i = 0; i < 10; i++) {
			p = (int *)malloc(sizeof(int)); //выделение памяти в цикле 10 раз
			*p = 0;
		}
		free(p); //а освобождение вне цикла - однократное. Утечка!

		return 0;
	}


Как избежать ошибок работы с динамической памятью?
++++++++++++++++++++++++++++++++++++++++++++++++++

* Во-первых, быть аккуратным и внимательным.
* Во-вторых, если память выделена на одном уровне, освобождение должно быть совершено на том же уровне. Например, если функция выделила память, она же должна ее освободить перед выходом. В исключительных ситуациях могут существовать "порождающие" функции, но их нужно "знать в лицо", их имена должны говорить об этом. С этой точки зрения пример плохой порождающий функции: стандартная функция Си создания дубликата строки strdup(). По ее имени не очевидно, что при этом выделяется динамическая память, которая обязательно должна быть освобождена.
* В-третьих, существуют специальные программные средства, которые позволяют искать утечки памяти, например Valgrind.

Работа с динамической памятью в С++
-----------------------------------

Хотя в С++ также в конечном счете используются системные вызовы по выделению и освобождению памяти, они "обернуты" в операторы new и delete. В С++ не рекомендуется использовать механизм  malloc() и free() без насущной необходимости обратной совместимости.


new
+++

Операция `new` предназначена для создания объекта.

.. code-block:: c

	int *p = new int; //выделить память для одного int
	int *pp = new int [10]; //выделить память для массива размера 10.

Время жизни объекта, созданного с помощью new, не ограничивается областью видимости, в которой он был создан. Операция new возвращает указатель на созданный объект. Если объект является массивом, возвращается указатель на начальный элемент массива. Например, обе операции new int и new int[1] возвратят int* , а типом new int[i][10] будет int(*)[10]. Если описывается тип массива, все размерности, кроме первой, должны быть выражениями-константами с положительным значением. Первая размерность массива может задаваться произвольным выражением.


delete
++++++

Операция delete уничтожает объект, созданный с помощью new.

.. code-block:: c

	delete p; //для удаления одного объекта
	delete[] pp; //для удаления динамического массива

Операндом delete должен быть указатель, который возвращает new. Эффект применения операции delete к указателю, который не получен в результате операции new, считается неопределенным и обычно приводит к опасным последствиям. Однако гарантируется, что удаление по указателю с нулевым значением безопасно.

Результат попытки доступа к удаленному объекту неопределен, а удаление объекта может изменить его значение. Более того, если выражение, задающее объект, является изменяемым адресом, его значение после удаления неопределено.

Результат удаления массива с помощью простого обращения delete не определен, так же как и удаление одиночного объекта с помощью delete [].


Двумерные массивы в С++
=======================

Стандартом языка Си определены многомерные массивы. Простейшая форма многомерного массива — двумерный массив.

Двумерные массивы представляют как матрицу, состоящую из строк и столбцов.

Объявление двумерного массива `A` с размерами 10 строк и 20 стролбцов выглядит следующим образом:

.. code-block:: c

	int A[10][20];

Обращение к элементу с индексами 1 и 2 двумерного массива `A` выглядит так: `A[1][2]`

В языке Си каждое измерение заключено в свои квадратные скобки. Первый индекс указывает индекс строки, а второй — индекс столбца.

Двумерный массив — это массив одномерных массивов (строк), последовательно расположенных в памяти.

.. image:: {filename}/images/lab3/static_array.png

Объем памяти в байтах, занимаемый двухмерным массивом, вычисляется по следующей формуле:

	`количество_байтов == размер_1-го_измерения × размер_2-го_измерения × sizeof(базовый_тип)`

В следующем примере элементам двумерного массива присваиваются числа от 1 до 20 и значения элементов выводятся на экран построчно.

.. code-block:: c

	#include <stdio.h>
	#include <stdlib.h>

	#define MATRIX_HEIGHT 4
	#define MATRIX_WIDTH 5

	void static_array_print(int A[][MATRIX_WIDTH], size_t N)
	{
		for(int i = 0; i < N; i++) {
			for(int j = 0; j < MATRIX_WIDTH; j++) {
				printf("%*d", 5, A[i][j]);
			}
			printf("\n");
		}
	}

	void static_array_test(size_t N)
	{
		int A[N][MATRIX_WIDTH];
		int x = 1;
		for(int i = 0; i < N; i++) {
			for(int j = 0; j < MATRIX_WIDTH; j++) {
				A[i][j] = x;
				x += 1;
			}
		}
		static_array_print(A, N);

		/*memory investigation*/
		printf("\n Direct memory access (not dangerous):\n");
		for(int *p = (int *)A; p < (int *)A + 20; p++)
			printf("%3d", *p);
		printf("\n\n");
	}

	int main()
	{
		static_array_test(MATRIX_HEIGHT);
		return 0;
	}

В этом примере `A[0][0]` имеет значение 1, `A[0][1]` — значение 2, `A[0][2]` — значение 3 и так далее до 20.

Передача массивов в функцию
---------------------------

Если двумерный массив нужно передать в функцию, то в нее передается только указатель на начальный элемент массива. В соответствующем формальном параметре **обязательно должен быть указан размер правого измерения**, то есть длина строки массива. Размер левого измерения указывать не обязательно.

Размер правого измерения необходим компилятору для того, чтобы внутри функции правильно вычислить адрес элемента массива, так как для этого компилятор должен знать длину строки массива. Например, функция, получающая двумерный массив целых размерностью 10×10, должна быть объявлена так:

.. code-block:: c

	void func1(int x[][10])
	{
	  /* … */
	}

Компилятор должен знать длину строки массива, чтобы внутри функции правильно вычислить адрес элемента массива. Если при компиляции функции это неизвестно, то невозможно определить, где начинается следующая строка, и вычислить адрес элемента в памяти.

Массивы указателей
==================

Как и объекты любых других типов, указатели могут быть собраны в массив.

Объявим одномерный массив из 10 указателей на объекты типа `int`:

.. code-block:: c

	int *A[10];

Для присвоения, например, адреса переменной var третьему элементу массива указателей, необходимо написать: `A[2] = &var`;

В результате этой операции, `*A[2]` принимает то же значение, что и `var`.

Для передачи массива указателей в функцию используется тот же метод, что и для любого другого массива: имя массива без индекса записывается как формальный параметр функции. Например, следующая функция может принять массив `A` в качестве аргумента:

.. code-block:: c

	void print_ptr_array(int *A[])
	{
		for(int i = 0; i < 10; i++) {
			printf("%d ", *A[i]);
		}
	}
	
Необходимо помнить, что `A` — это не указатель на целые, а указатель на массив указателей на целые. Поэтому параметр A нужно объявить как массив указателей на целые. Нельзя объявить A просто как указатель на целые, потому что он представляет собой *указатель на указатель*.

Ту же фунцию допустимо описать так:

.. code-block:: c

	void print_ptr_array(int **A)
	{
		for(int i = 0; i < 10; i++) {
			printf("%d ", *A[i]);
		}
	}
	

Динамические двумерные массивы в С++
====================================

Динамические двумерные массивы в языке Си имеют сложный способ представления в памяти компьютера.

Рассмотрим одномерный массив из 10 указателей на объекты типа `int`:

.. code-block:: c

	int *A[10];

A представляет собой **указатель на указатель** на `int`.

Кроме того, массив указателей может быть не статическим, а динамическим:

.. code-block:: c

	int **A;

Следующий шаг сделать очень просто — по указателям, хранящимся в массиве `A` могут лежать не по одному значению, а по одномерному динамическому массиву таких значений.

.. image:: {filename}/images/lab3/dynamic_array.png

Передача динамических двумерных массивов в функцию
--------------------------------------------------

Динамические массивы передаются в функции по-другому, *передается указатель на начало массива указателей*, а длина строки и количество строк вообще нигде не фигурируют. Контроль за границами массивов лежит полностью на программисте, поэтому, вероятно, стоит передавать в функцию отдельными параметрами размеры массива — количество строк и столбцов.

.. code-block:: c

	#include <stdio.h>
	#include <stdlib.h>

	#define MATRIX_HEIGHT 4
	#define MATRIX_WIDTH 5

	void dynamic_array_print(int **A, size_t N, size_t M)
	{
		for(int i = 0; i < N; i++) {
			for(int j = 0; j < M; j++) {
				printf("%*d", 5, A[i][j]);
			}
			printf("\n");
		}
	}

	/*
		return pointer on 2d dynamic array
		!allocates memory -> to be freed later
	*/
	int ** dynamic_array_alloc(size_t N, size_t M)
	{
		int **A = (int **)malloc(N*sizeof(int *));
		for(int i = 0; i < N; i++) {
			A[i] = (int *)malloc(M*sizeof(int));
		}
		return A;
	}

	void dynamic_array_free(int **A, size_t N)
	{
		for(int i = 0; i < N; i++) {
			free(A[i]);
		}
		free(A);
	}

	void dynamic_array_test(size_t N, size_t M)
	{
		int **A = dynamic_array_alloc(N, M);
		int x = 1;
		for(int i = 0; i < N; i++) {
			for(int j = 0; j < M; j++) {
				A[i][j] = x;
				x += 1;
			}
		}
		dynamic_array_print(A, N, M);
		/*memory investigation*/
		printf("\n Pointers to lines: ");
		for(int **p = A; p < A + 3; p++)
			printf("%10d", (long int)*p);
		printf("\n Direct memory access (dangerous!!!):\n");
		for(int *p = (int*)*A; p < (int*)*A + 25; p++)
			printf("%d\t", *p);
		dynamic_array_free(A, N);
	}

	int main()
	{
		dynamic_array_test(MATRIX_HEIGHT, MATRIX_WIDTH);
		return 0;
	}

Выделение памяти под динамический массив
----------------------------------------

Как видно из примера, создание такой сложной структуры как двумерный динамический массив требует множества системных вызовов по выделению памяти:

.. code-block:: c

	int **A = (int **)malloc(N*sizeof(int *));
	for(int i = 0; i < N; i++) {
		A[i] = (int *)malloc(M*sizeof(int));
	}

При таком выделении памяти нельзя просто взять, и освободить память по адресу A, т.к. будет возникать утечка памяти.

Правильное очищение таково:

.. code-block:: c

	for(int i = 0; i < N; i++) {
		free(A[i]);
	}
	free(A);

Альтернатива такова: при некотором владении адресной арифметикой можно выделить память сразу для всех одномерных массивов, необходимых для организации двумерного динамического массива:

.. code-block:: c

	int ** A = malloc(n*sizeof(int*) + n*m*sizeof(int));
	char * pc = A;
	pc += n*sizeof(int*);
	for (int i=0; i<n; i++)
		A[i] = pc + i*sizeof(m*sizeof(int));

Тогда освобождение памяти будет происходить очень легко:

.. code-block:: c

	free(A);