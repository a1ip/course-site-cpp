Передача параметров в функции   
#############################

:date: 2016-09-15 09:00
:status: draft

.. default-role:: code
.. contents:: Содержание

	
Функции с параметрами в С++
===========================

Исходные данные функция должена получать из своих параметров.
Список параметров в заголовке функции называется *список формальных параметров*.

Параметр функции — это принятый функцией аргумент, значение, переданное из вызывающего кода.

Различают:

* фактический параметр — что именно передали в функцию при её вызове (в частности, на этапе выполнения программы);
* формальный параметр — аргумент, указываемый при объявлении и определении функции.

Пример функции с одним параметром:
 
.. code-block:: c

	// Объявление функции.
	// int a - формальный параметр (имя параметра может отсутствовать).
	int my_function(int a);
	 
	// Определение функции.
	// int b - формальный параметр (имя параметра может не совпадать с указанным при объявлении функции)
	int my_function(int b)
	{
	   return b + 1;
	}
	 
	int main()
	{
		int c = 0;
		my_function(c); // Вызов функции. c - фактический параметр.
		return 0;
	}

Передача параметра по значению
------------------------------

Параметры в С++ передаются *по значению*: вызывающая функция копирует в память, доступную вызываемой функции (сегмент стека), непосредственное фактическое значение.

Изменение копии переменной, соответственно, оригинал не затрагивает!

Упражнение №1
+++++++++++++

.. code-block:: c

	void bad_incrementor(int x)
	{
		x++;
		std::cout << 'x changed: ' << x << std::endl;
	}

Вызвать функцию `bad_incrementor()`, которая изменяет формальный параметр, и убедиться в том, что фактический параметр неизменен.


Передача параметра по адресу
----------------------------

Чтобы изменить переменную изнутри функции, можно передавать ей не значение, а *адрес переменной*, подлежащей изменению. При вызове такой функции приходится использовать операцию взятия адреса. Например: `g(&x)`.

Передача параметра по адресу является частным случаем передачи по значению: передаваемым значением является адрес, по которому можно найти другое значение — значение переменной `x`.

Упражнение №2
+++++++++++++

Описать функцию `good_incrementor()` в соответствии с прототипом.
Она должна увеличивать значение переменной x на 1.

.. code-block:: c

	void good_incrementor(int *x);
	
	int main()
	{
		int x = 1;
		std::cout << 'x initial: ' << x << std::endl;
		good_incrementor(&x);
		std::cout << 'x changed: ' << x << std::endl;
		
		return 0;
	}

Не забывайте, что в теле функции x — это *указатель*, который при обращении нужно разыменовывать.

Передача параметра по ссылке
----------------------------

Упражнение №3
+++++++++++++

Описать функцию `better_incrementor()` в соответствии с прототипом.
Она также должна увеличивать значение переменной x на 1.

.. code-block:: c

	void good_incrementor(int &x);

Проверьте её работоспособность.
Не забудьте, что ссылку в теле функции не нужно разыменовывать, а при вызове не требуется передавать адрес.


Прототипы функций
=================

**Определение функции** содержит как *заголовок*, так и *тело функции*:

Благодаря принципу *раздельной компиляции*, на самом этапе компиляции *не требуется тело функции* — достаточно только заголовка.

**Прототипом** функции в языке Си или C++ называется *объявление функции*, не содержащее тела функции, но указывающее:

* имя функции,
* количество аргументов (арность),
* типы аргументов,
* возвращаемый тип данных.

В то время как определение функции описывает, *что именно* делает функция, прототип функции — это описание её *интерфейса*.

.. code-block:: c

	double new_style(int a, double *x); /* прототип функции */

Обратите внимание на точку с запятой после закрывающей круглой скобки. Она значит, что тела функции тут не предполагается.

В прототипе имена аргументов являются необязательными, тем не менее, необходимо указывать тип вместе со всеми модификаторами (например, если это указатель или константный аргумент):

.. code-block:: c

	double alt_style(int, double *); /* альтернативная форма прототипа */

На этапе компоновки тело функции всё-таки понадобится, иначе программу не удастся собрать.

Протипы функций модуля (отдельной `единицы трансляции`_ программы) выделяют в **заголовочный файл** `.h`.
Прототип при компиляции должен находиться выше по тексту, чем место использования функции, поэтому подключение (`include`) заголовочных файлов происходит в самом начале файла `.cpp`, использующего данный модуль.

.. _`единицы трансляции`:https://ru.wikipedia.org/wiki/%D0%95%D0%B4%D0%B8%D0%BD%D0%B8%D1%86%D0%B0_%D1%82%D1%80%D0%B0%D0%BD%D1%81%D0%BB%D1%8F%D1%86%D0%B8%D0%B8

Квалификатор типа const
=======================

Для гарантии неизменности переменной можно использовать квалификатор const.

const и скалярные переменные
----------------------------

.. code-block:: c

	const int hello = 3;

`const` перед `hello` означает, что *во время компиляции* происходит проверка, что переменная `hello` никогда не меняется.

Если вы попытаетесь изменить или переопределить `hello`, компилятор остановит вас:

.. code-block:: text

	gcc-5.3.0:
	error: increment of read-only variable 'hello'
		 hello++;
			  ^
	error: assignment of read-only variable 'hello'
		 hello = 92;
			   ^


Кроме того, C++ не сильно беспокоится о том, где расположен `const` до тех пор пока он находится перед идентификатором, так что объявления `const int` и `int const` идентичны:

.. code-block:: c

	const int hello = 3;
	int const hello = 3;

const и массивы
---------------

Вы можете указать const для всего массива.

.. code-block:: c

	const int numbers[] = {1, 2, 3, 4, 5};


const также может указываться после объявления типа:

.. code-block:: c

	int const numbers[] = {1, 2, 3, 4, 5};


Если вы попытаетесь изменить `numbers[]`, компилятор остановит вас:

.. code-block:: text

	gcc-5.3.0:
	error: assignment of read-only location 'numbers[3]'
		 numbers[3] = 12;
               ^

const и указатели
-----------------

`const` для указателей — вот где основные сложности!

Нужно быть осторожным в определении *места расположения* для `const`, поскольку это повлияет на то, *что именно будет константой* - или сам указатель будет константой, или константой будет то место, *на которое* указатель указывает.

Например, выражение:

.. code-block:: c

	const int * constant_1; // указатель на константу
	int const * constant_2; // альтернативная запись указателя на константу

декларирует указатели с именами `constant_1` и `constant_2`, которые указывают на какое-то постоянное значение типа `int`. Т. е. *сам указатель изменять можно*, но значение, на которое указывает указатель, изменять нельзя.


А это выражение:

.. code-block:: c

	int * const constant_3; // константный указатель на переменную

декларирует, что `constant_3` является *постоянным указателем* на некоторую переменную `int`. Т. е. значение указателя будет всегда неизменным, а значение переменной, на которую указывает указатель, менять можно.

Внимание, двойной `const`:

.. code-block:: c

	int const * const constant_4; // константный указатель на константу

декларирует, что constant_4 является постоянным указателем, указывающим на постоянный `int`. Просто запомните, что `const` прикладывается непосредственно к объекту слева от `const` (кроме случая, когда слева от `const` нет ничего; тогда `const` прикладывается непосредственно к тому, что справа от него).

Общие слова про `const`
-----------------------

Объявление `const` не изменяет поведение программы, а действия с `const` проверяются только во время компиляции.
`const` существует, чтобы помочь людям справиться со сложностями, немного легче:

* помогает самодокументированию ожидаемого поведения переменных и параметров (служит простой защитой, если вы забудете что должно и не должно изменяться в будущем)

* const всегда можно обойти с помощью явного приведения типов или копирования памяти. 
Ваш компилятор по своему усмотрению может решить разместить неизменяемые переменные в месте доступном только для чтения, так что если вы попытаетесь обойти `const` вы можете столкнуться с неопределенным поведением.

* Факультативно: дополнительный материал про тройной `const` в `заметке на habrahabr`_.*

.. _`заметке на habrahabr`: https://habrahabr.ru/post/301332/


Двумерные массивы в С++
=======================


Динамические двумерные массивы в С++
====================================


