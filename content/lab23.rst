Клеточные автоматы: введение в распараллеливание
#################################################

:date: 2017-04-06 09:00
:status: draft


.. default-role:: code
.. contents:: Содержание


Игра «Жизнь» Джона Конвея
=========================

`Игра «Жизнь»`__ — это двумерный клеточный автомат, предложенный математиком Джоном Конвеем. Поведение этого клеточного
автомата подчиняется следующим правилам:

#. Автомат работает на плоскости, разделённой на одинаковые квадратные клетки.
#. Каждая клетка может находиться в двух состояниях: живая или мёртвая.
#. В начальный момент времени задано первое поколение — расположение живых клеток на плоскости.
#. Каждое следующее поколение рассчитывается исходя из состояния прошлого поколения по следующим правилам:

   * в мёртвой клетке зарождается жизнь, если у этой клетки ровно три живых соседних клетки;
   * если у живой клетки есть две или три живых соседних клетки, то клетка продолжает жить, в противном случае клетка
     погибает.

#. Игра завершается в трёх случаях:

   * все клетки погибли;
   * клетки сформировали устойчивую конфигурацию (т.е. на новом шаге не родилось и не погибло ни одной клетки);
   * клетки сформировали периодическую конфигурацию (т.е. клетки в точности повторили свою конфигурацию в один из
     предыдущих моментов).

См. также__

.. __: https://ru.wikipedia.org/wiki/%D0%96%D0%B8%D0%B7%D0%BD%D1%8C_(%D0%B8%D0%B3%D1%80%D0%B0)

Как нетрудно видеть, события в разных частях игрового поля, - слабо связаны между собой. В сущности, события на двух соседних участках связаны между собой только в случае, если на их границе должно произойти рождение или смерть. Это значит, что данная задача имеет огромные возможности для распараллеливания. 

Исходники
=========

Исходный код программы (нераспараллеленный) life2d.c и конфигурационные файлы для разных начальных конфигураций (с расширением .cfg) см. в папке /tmp/life
Начальные конфигурации записываются в файлах с расширением .cfg в формате 
* число шагов для обсчета
* интервал между сохраняемыми состояниями в шагах
* размер поля : по горизонтали - через пробел - по вертикали 
* последовательно в столбец координаты живых клеток, сперва x, потом y

Пример. 
+++++++

Содержание файла lwss.cfg

.. code-block:: c
	100
	1
	40 20
	0 11
	1 10
	2 10
	3 10
	4 10
	0 13
	4 11
	4 12
	3 13

Это означает, что нужно посчитать 100 шагов, конфигурации сохранять через каждый шаг, поле имеет размер 20*40

За чтение конфигураций отвечает функция life_init():

.. code-block:: c
	void life_init(const char *path, life_t *l)
	{
		FILE *fd = fopen(path, "r");
		assert(fd);
		assert(fscanf(fd, "%d\n", &l->steps));
		assert(fscanf(fd, "%d\n", &l->save_steps));
		printf("Steps %d, save every %d step.\n", l->steps, l->save_steps);
		assert(fscanf(fd, "%d %d\n", &l->nx, &l->ny));
		printf("Field size: %dx%d\n", l->nx, l->ny);

		l->u0 = (int*)calloc(l->nx * l->ny, sizeof(int));
		l->u1 = (int*)calloc(l->nx * l->ny, sizeof(int));
	
		int i, j, r, cnt;
		cnt = 0;
		while ((r = fscanf(fd, "%d %d\n", &i, &j)) != EOF) {
			l->u0[ind(i, j)] = 1;
			cnt++;
		}
		printf("Loaded %d life cells.\n", cnt);
		fclose(fd);
	}

За сохранение промежуточных конфигураций - life_save_vtk()
За изменение конфигурации с течением времени  - life_step()

.. code-block:: c
	void life_step(life_t *l)
	{
		int i, j;
		for (j = 0; j < l->ny; j++) {
			for (i = 0; i < l->nx; i++) {
				int n = 0;
				n += l->u0[ind(i+1, j)];	
				n += l->u0[ind(i+1, j+1)];
				n += l->u0[ind(i,   j+1)];
				n += l->u0[ind(i-1, j)];
				n += l->u0[ind(i-1, j-1)];
				n += l->u0[ind(i,   j-1)];
				n += l->u0[ind(i-1, j+1)];
				n += l->u0[ind(i+1, j-1)];
				l->u1[ind(i,j)] = 0;
				if (n == 3 && l->u0[ind(i,j)] == 0) {
					l->u1[ind(i,j)] = 1;
				}
				if ((n == 3 || n == 2) && l->u0[ind(i,j)] == 1) {
					l->u1[ind(i,j)] = 1;
				}
			}
		}
		int *tmp;
		tmp = l->u0;
		l->u0 = l->u1;
		l->u1 = tmp;
	}


Задание
-------

Одномерная декомпозиция. MPI_Send/MPI_Recv. Декомпозиция с перекрытиями, пересылки перекрытий. Разделение по одной оси.
Распараллелить данный алгоритм игры на 2 процесса по горизонтали (или по вертикали): так, чтобы один обрабатывал левую половину поля, а другой - правую. Замерить быстродействие на разных конфигурациях. (глайдер и ружьё)
